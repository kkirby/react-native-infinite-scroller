function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @ts-nocheck
import { State } from 'react-native-gesture-handler';
import EventEmitter from 'events';
import { decayHelper, springHelper } from './ReanimatedHelpers';
import Animated from 'react-native-reanimated';
const {
  call,
  stopClock,
  startClock,
  diff,
  debug,
  round
} = Animated;
const LogicState = {
  IDLE: 0,
  DECAY: 1,
  SPRING: 2,
  GESTURE: 3,
  SCROLL_TO: 4
};
export default function AnimationLogic() {
  const eventEmitter = new EventEmitter();
  /**
   * This is used to determine velocity. The clock is started and stopped,
   * and the time in between start and stops is used to calculate velocity.
   **/

  let baseClock = new Animated.Clock();
  /**
   * Stores the current state of our primary logic
   **/

  let logicState = new Animated.Value(LogicState.IDLE);
  let previousLogicState = new Animated.Value(LogicState.IDLE);
  let x = new Animated.Value(0);
  let velocity = new Animated.Value(0);
  let itemWidth = new Animated.Value(0);
  let wrapperWidth = new Animated.Value(0);
  /**
   * Holds the center offset
   **/

  let center = Animated.divide(Animated.add(wrapperWidth, itemWidth), 2);
  let centerScroll = new Animated.Value(0);
  /**
   * Holds the value of X + the center offset (if centerScroll is 1).
   **/

  let xWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(x, center), itemWidth)], [x])]);
  let maxScrollX = new Animated.Value(0);
  /**
   * Holds the destination scroll value when `scrollTo` is called.
   **/

  let scrollToValue = new Animated.Value(0);
  /**
   * Holds wether or not the scroll to should be animated.
   **/

  let scrollToWithAnimation = new Animated.Value(0);
  /**
   * Handler for when the x value changes.
   **/

  const onXChange = value => {
    eventEmitter.emit('change', value[0]);
  };
  /**
   * Handler for when the scroll ends.
   **/


  const onScrollEnd = value => {
    eventEmitter.emit('scrollEnd', value[0]);
  };
  /**
   * Handles spring related stuff.
   **/


  const springState = (() => {
    let snapPoint = new Animated.Value(0);
    const helper = springHelper(x, snapPoint, velocity);
    return _objectSpread({}, helper, {
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(snapPoint, Animated.multiply(round(Animated.divide([Animated.cond(Animated.eq(logicState, LogicState.SPRING), [x], [scrollToValue])], itemWidth)), itemWidth)), Animated.cond(Animated.neq(maxScrollX, 0), [Animated.cond(Animated.greaterThan(x, 0), [Animated.set(snapPoint, 0)], Animated.cond(Animated.lessThan(x, maxScrollX), [Animated.set(snapPoint, maxScrollX)]))])]), helper.tick]),
      stop: helper.stop
    });
  })();
  /**
   * Defines if we should spring or decay based on maxScrollX.
   **/


  const shouldSpringInsteadOfDecay = Animated.block([Animated.cond(Animated.eq(maxScrollX, 0), [0], Animated.cond(Animated.greaterThan(x, 0), [1], Animated.cond(Animated.lessThan(x, maxScrollX), [1], [0])))]);
  /**
   * Handles decay related stuff.
   **/

  const decayState = (() => {
    const helper = decayHelper(x, velocity, 0.997);
    /**
     * Defines if the decay ended up going past our min/max x (if set)
     **/

    let overshot = new Animated.Value(0);
    return _objectSpread({}, helper, {
      overshot,
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(overshot, 0), helper.tick], [Animated.cond(Animated.and(Animated.neq(maxScrollX, 0), Animated.or(Animated.greaterThan(x, 0), Animated.lessThan(x, maxScrollX))), [Animated.set(overshot, 1), Animated.set(velocity, helper.velocity), helper.stop], [helper.tick])])])
    });
  })();
  /**
   * Handles everything related to gestures
   **/


  const gestureState = (() => {
    let newX = new Animated.Value(0);
    let pointX = new Animated.Value(0);
    let distX = new Animated.Value(0);
    let deltaX = new Animated.Value(0);
    let startTime = new Animated.Value(0);
    let endTime = new Animated.Value(0);
    let data = {
      x: new Animated.Value(0),
      state: new Animated.Value(-1)
    };
    /**
     * Handler for when the gesture starts.
     **/

    let start = Animated.block([startClock(baseClock), Animated.set(logicState, LogicState.GESTURE), Animated.set(distX, 0), Animated.set(startTime, baseClock), Animated.set(pointX, data.x)]);
    /**
     * Handler for gesture move.
     **/

    let move = Animated.block([Animated.set(deltaX, Animated.sub(data.x, pointX)), Animated.set(pointX, data.x), Animated.set(distX, Animated.add(distX, deltaX)), Animated.set(newX, Animated.add(x, deltaX)), Animated.cond(Animated.neq(maxScrollX, 0), [Animated.cond(Animated.or(Animated.greaterThan(newX, 0), Animated.lessThan(newX, maxScrollX)), [Animated.set(newX, Animated.add(x, Animated.divide(deltaX, 3)))])]), Animated.set(x, newX)]);
    /**
     * Handler for gesture end
     **/

    let end = Animated.block([stopClock(baseClock), Animated.set(endTime, baseClock), Animated.set(velocity, Animated.multiply(Animated.divide(distX, Animated.sub(endTime, startTime)), 1000)), Animated.cond(Animated.eq(shouldSpringInsteadOfDecay, 0), [Animated.set(logicState, LogicState.DECAY), decayState.tick], [Animated.set(logicState, LogicState.SPRING), springState.tick])]);
    return {
      data,
      start,
      move,
      end
    };
  })();
  /**
   * Primary logic to determine the value of `x`.
   **/


  const calculatedTransX = Animated.block([Animated.cond(Animated.eq(logicState, LogicState.IDLE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.start])], Animated.cond(Animated.eq(logicState, LogicState.GESTURE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.move], Animated.cond(Animated.eq(gestureState.data.state, State.END), [gestureState.end]))], [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [decayState.stop, springState.stop, gestureState.start], Animated.cond(Animated.eq(logicState, LogicState.DECAY), [springState.stop, decayState.tick, Animated.cond(Animated.eq(decayState.finished, 1), [Animated.cond(Animated.eq(decayState.overshot, 0), [Animated.set(velocity, 0)]), Animated.set(logicState, LogicState.SPRING), springState.tick])], Animated.cond(Animated.eq(logicState, LogicState.SPRING), [decayState.stop, springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])], Animated.cond(Animated.eq(logicState, LogicState.SCROLL_TO), [Animated.cond(Animated.eq(scrollToWithAnimation, 0), [decayState.stop, springState.stop, Animated.set(x, scrollToValue), Animated.set(logicState, LogicState.IDLE)], [Animated.set(velocity, 0), Animated.cond(Animated.or(Animated.neq(previousLogicState, logicState), Animated.neq(diff(scrollToValue), 0)), [decayState.stop, springState.stop]), springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])])]))))])), Animated.cond(Animated.and(Animated.neq(diff(logicState), 0), Animated.eq(logicState, LogicState.IDLE)), [call([xWithCenter, logicState], onScrollEnd)]), call([xWithCenter], onXChange), Animated.set(previousLogicState, logicState), xWithCenter]);
  const gestureHandler = Animated.event([{
    nativeEvent: gestureState.data
  }]);
  const result = Object.create(eventEmitter);
  Object.assign(result, {
    x: calculatedTransX,
    gestureHandler,

    updateItemWidth(value) {
      itemWidth.setValue(value);
    },

    updateWrapperWidth(value) {
      wrapperWidth.setValue(value);
    },

    updateCenterScroll(value) {
      centerScroll.setValue(value ? 1 : 0);
    },

    updateMaxScroll(value) {
      maxScrollX.setValue(value);
    },

    scrollTo(value, withAnimation = true) {
      scrollToValue.setValue(value);
      scrollToWithAnimation.setValue(withAnimation ? 1 : 0);
      logicState.setValue(LogicState.SCROLL_TO);
    }

  });
  return result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9BbmltYXRpb25Mb2dpYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJTdGF0ZSIsIkV2ZW50RW1pdHRlciIsImRlY2F5SGVscGVyIiwic3ByaW5nSGVscGVyIiwiQW5pbWF0ZWQiLCJjYWxsIiwic3RvcENsb2NrIiwic3RhcnRDbG9jayIsImRpZmYiLCJkZWJ1ZyIsInJvdW5kIiwiTG9naWNTdGF0ZSIsIklETEUiLCJERUNBWSIsIlNQUklORyIsIkdFU1RVUkUiLCJTQ1JPTExfVE8iLCJBbmltYXRpb25Mb2dpYyIsImV2ZW50RW1pdHRlciIsImJhc2VDbG9jayIsIkNsb2NrIiwibG9naWNTdGF0ZSIsIlZhbHVlIiwicHJldmlvdXNMb2dpY1N0YXRlIiwieCIsInZlbG9jaXR5IiwiaXRlbVdpZHRoIiwid3JhcHBlcldpZHRoIiwiY2VudGVyIiwiY2VudGVyU2Nyb2xsIiwieFdpdGhDZW50ZXIiLCJtYXhTY3JvbGxYIiwic2Nyb2xsVG9WYWx1ZSIsInNjcm9sbFRvV2l0aEFuaW1hdGlvbiIsIm9uWENoYW5nZSIsInZhbHVlIiwiZW1pdCIsIm9uU2Nyb2xsRW5kIiwic3ByaW5nU3RhdGUiLCJzbmFwUG9pbnQiLCJoZWxwZXIiLCJ0aWNrIiwicnVubmluZyIsInN0b3AiLCJzaG91bGRTcHJpbmdJbnN0ZWFkT2ZEZWNheSIsImRlY2F5U3RhdGUiLCJvdmVyc2hvdCIsImdlc3R1cmVTdGF0ZSIsIm5ld1giLCJwb2ludFgiLCJkaXN0WCIsImRlbHRhWCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJkYXRhIiwic3RhdGUiLCJzdGFydCIsIm1vdmUiLCJlbmQiLCJjYWxjdWxhdGVkVHJhbnNYIiwiQUNUSVZFIiwiRU5EIiwiZmluaXNoZWQiLCJnZXN0dXJlSGFuZGxlciIsImV2ZW50IiwibmF0aXZlRXZlbnQiLCJyZXN1bHQiLCJPYmplY3QiLCJjcmVhdGUiLCJhc3NpZ24iLCJ1cGRhdGVJdGVtV2lkdGgiLCJzZXRWYWx1ZSIsInVwZGF0ZVdyYXBwZXJXaWR0aCIsInVwZGF0ZUNlbnRlclNjcm9sbCIsInVwZGF0ZU1heFNjcm9sbCIsInNjcm9sbFRvIiwid2l0aEFuaW1hdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFHQSxTQUFRQSxLQUFSLFFBQW9CLDhCQUFwQjtBQUNBLE9BQU9DLFlBQVAsTUFBeUIsUUFBekI7QUFDQSxTQUFRQyxXQUFSLEVBQXFCQyxZQUFyQixRQUF3QyxxQkFBeEM7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLHlCQUFyQjtBQUNBLE1BQU07QUFBQ0MsRUFBQUEsSUFBRDtBQUFPQyxFQUFBQSxTQUFQO0FBQWtCQyxFQUFBQSxVQUFsQjtBQUE4QkMsRUFBQUEsSUFBOUI7QUFBb0NDLEVBQUFBLEtBQXBDO0FBQTJDQyxFQUFBQTtBQUEzQyxJQUFvRE4sUUFBMUQ7QUFFQSxNQUFNTyxVQUFVLEdBQUc7QUFDbEJDLEVBQUFBLElBQUksRUFBRSxDQURZO0FBRWxCQyxFQUFBQSxLQUFLLEVBQUUsQ0FGVztBQUdsQkMsRUFBQUEsTUFBTSxFQUFFLENBSFU7QUFJbEJDLEVBQUFBLE9BQU8sRUFBRSxDQUpTO0FBS2xCQyxFQUFBQSxTQUFTLEVBQUU7QUFMTyxDQUFuQjtBQVFBLGVBQWUsU0FBU0MsY0FBVCxHQUEwQjtBQUN4QyxRQUFNQyxZQUFZLEdBQUcsSUFBSWpCLFlBQUosRUFBckI7QUFFQTs7Ozs7QUFJQSxNQUFJa0IsU0FBUyxHQUFHLElBQUlmLFFBQVEsQ0FBQ2dCLEtBQWIsRUFBaEI7QUFDQTs7OztBQUdBLE1BQUlDLFVBQVUsR0FBRyxJQUFJakIsUUFBUSxDQUFDa0IsS0FBYixDQUFtQlgsVUFBVSxDQUFDQyxJQUE5QixDQUFqQjtBQUNBLE1BQUlXLGtCQUFrQixHQUFHLElBQUluQixRQUFRLENBQUNrQixLQUFiLENBQW1CWCxVQUFVLENBQUNDLElBQTlCLENBQXpCO0FBRUEsTUFBSVksQ0FBQyxHQUFHLElBQUlwQixRQUFRLENBQUNrQixLQUFiLENBQW1CLENBQW5CLENBQVI7QUFDQSxNQUFJRyxRQUFRLEdBQUcsSUFBSXJCLFFB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a0I7QUFFckJJLElBQUFBLGNBRnFCOztBQUdyQk8sSUFBQUEsZUFBZSxDQUFDbkMsS0FBRCxFQUFRO0FBQ3RCVCxNQUFBQSxTQUFTLENBQUM2QyxRQUFWLENBQW1CcEMsS0FBbkI7QUFDQSxLQUxvQjs7QUFNckJxQyxJQUFBQSxrQkFBa0IsQ0FBQ3JDLEtBQUQsRUFBUTtBQUN6QlIsTUFBQUEsWUFBWSxDQUFDNEMsUUFBYixDQUFzQnBDLEtBQXRCO0FBQ0EsS0FSb0I7O0FBU3JCc0MsSUFBQUEsa0JBQWtCLENBQUN0QyxLQUFELEVBQVE7QUFDekJOLE1BQUFBLFlBQVksQ0FBQzBDLFFBQWIsQ0FBc0JwQyxLQUFLLEdBQUcsQ0FBSCxHQUFPLENBQWxDO0FBQ0EsS0FYb0I7O0FBWXJCdUMsSUFBQUEsZUFBZSxDQUFDdkMsS0FBRCxFQUFRO0FBQ3RCSixNQUFBQSxVQUFVLENBQUN3QyxRQUFYLENBQW9CcEMsS0FBcEI7QUFDQSxLQWRvQjs7QUFlckJ3QyxJQUFBQSxRQUFRLENBQUN4QyxLQUFELEVBQVF5QyxhQUFhLEdBQUcsSUFBeEIsRUFBOEI7QUFDckM1QyxNQUFBQSxhQUFhLENBQUN1QyxRQUFkLENBQXVCcEMsS0FBdkI7QUFDQUYsTUFBQUEscUJBQXFCLENBQUNzQyxRQUF0QixDQUErQkssYUFBYSxHQUFHLENBQUgsR0FBTyxDQUFuRDtBQUNBdkQsTUFBQUEsVUFBVSxDQUFDa0QsUUFBWCxDQUFvQjVELFVBQVUsQ0FBQ0ssU0FBL0I7QUFDQTs7QUFuQm9CLEdBQXRCO0FBc0JBLFNBQU9rRCxNQUFQO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuXG5pbXBvcnQgcmUgZnJvbSAnQGtraXJiYXRza2kvanMtdG8tcmVhbmltYXRlZC5tYWNybyc7XG5pbXBvcnQge1N0YXRlfSBmcm9tICdyZWFjdC1uYXRpdmUtZ2VzdHVyZS1oYW5kbGVyJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7ZGVjYXlIZWxwZXIsIHNwcmluZ0hlbHBlcn0gZnJvbSAnLi9SZWFuaW1hdGVkSGVscGVycyc7XG5pbXBvcnQgQW5pbWF0ZWQgZnJvbSAncmVhY3QtbmF0aXZlLXJlYW5pbWF0ZWQnO1xuY29uc3Qge2NhbGwsIHN0b3BDbG9jaywgc3RhcnRDbG9jaywgZGlmZiwgZGVidWcsIHJvdW5kfSA9IEFuaW1hdGVkO1xuXG5jb25zdCBMb2dpY1N0YXRlID0ge1xuXHRJRExFOiAwLFxuXHRERUNBWTogMSxcblx0U1BSSU5HOiAyLFxuXHRHRVNUVVJFOiAzLFxuXHRTQ1JPTExfVE86IDQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbmltYXRpb25Mb2dpYygpIHtcblx0Y29uc3QgZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cdC8qKlxuXHQgKiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHZlbG9jaXR5LiBUaGUgY2xvY2sgaXMgc3RhcnRlZCBhbmQgc3RvcHBlZCxcblx0ICogYW5kIHRoZSB0aW1lIGluIGJldHdlZW4gc3RhcnQgYW5kIHN0b3BzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHZlbG9jaXR5LlxuXHQgKiovXG5cdGxldCBiYXNlQ2xvY2sgPSBuZXcgQW5pbWF0ZWQuQ2xvY2soKTtcblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBvdXIgcHJpbWFyeSBsb2dpY1xuXHQgKiovXG5cdGxldCBsb2dpY1N0YXRlID0gbmV3IEFuaW1hdGVkLlZhbHVlKExvZ2ljU3RhdGUuSURMRSk7XG5cdGxldCBwcmV2aW91c0xvZ2ljU3RhdGUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoTG9naWNTdGF0ZS5JRExFKTtcblxuXHRsZXQgeCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0bGV0IHZlbG9jaXR5ID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdGxldCBpdGVtV2lkdGggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdGxldCB3cmFwcGVyV2lkdGggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0LyoqXG5cdCAqIEhvbGRzIHRoZSBjZW50ZXIgb2Zmc2V0XG5cdCAqKi9cblx0bGV0IGNlbnRlciA9IHJlKCh3cmFwcGVyV2lkdGggKyBpdGVtV2lkdGgpIC8gMik7XG5cdGxldCBjZW50ZXJTY3JvbGwgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgdmFsdWUgb2YgWCArIHRoZSBjZW50ZXIgb2Zmc2V0IChpZiBjZW50ZXJTY3JvbGwgaXMgMSkuXG5cdCAqKi9cblx0bGV0IHhXaXRoQ2VudGVyID0gcmUoKCkgPT4ge1xuXHRcdGlmIChjZW50ZXJTY3JvbGwgPT09IDEpIHtcblx0XHRcdHggKyBjZW50ZXIgLSBpdGVtV2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHg7XG5cdFx0fVxuXHR9KTtcblxuXHRsZXQgbWF4U2Nyb2xsWCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHQvKipcblx0ICogSG9sZHMgdGhlIGRlc3RpbmF0aW9uIHNjcm9sbCB2YWx1ZSB3aGVuIGBzY3JvbGxUb2AgaXMgY2FsbGVkLlxuXHQgKiovXG5cdGxldCBzY3JvbGxUb1ZhbHVlID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdC8qKlxuXHQgKiBIb2xkcyB3ZXRoZXIgb3Igbm90IHRoZSBzY3JvbGwgdG8gc2hvdWxkIGJlIGFuaW1hdGVkLlxuXHQgKiovXG5cdGxldCBzY3JvbGxUb1dpdGhBbmltYXRpb24gPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIHggdmFsdWUgY2hhbmdlcy5cblx0ICoqL1xuXHRjb25zdCBvblhDaGFuZ2UgPSB2YWx1ZSA9PiB7XG5cdFx0ZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHZhbHVlWzBdKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlciBmb3Igd2hlbiB0aGUgc2Nyb2xsIGVuZHMuXG5cdCAqKi9cblx0Y29uc3Qgb25TY3JvbGxFbmQgPSB2YWx1ZSA9PiB7XG5cdFx0ZXZlbnRFbWl0dGVyLmVtaXQoJ3Njcm9sbEVuZCcsIHZhbHVlWzBdKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBzcHJpbmcgcmVsYXRlZCBzdHVmZi5cblx0ICoqL1xuXHRjb25zdCBzcHJpbmdTdGF0ZSA9ICgoKSA9PiB7XG5cdFx0bGV0IHNuYXBQb2ludCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHRcdGNvbnN0IGhlbHBlciA9IHNwcmluZ0hlbHBlcih4LCBzbmFwUG9pbnQsIHZlbG9jaXR5KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHQuLi5oZWxwZXIsXG5cdFx0XHR0aWNrOiByZSgoKSA9PiB7XG5cdFx0XHRcdGlmIChoZWxwZXIucnVubmluZyA9PT0gMCkge1xuXHRcdFx0XHRcdHNuYXBQb2ludCA9XG5cdFx0XHRcdFx0XHRyb3VuZChcblx0XHRcdFx0XHRcdFx0KCgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5TUFJJTkcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHg7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNjcm9sbFRvVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KSAvIGl0ZW1XaWR0aCxcblx0XHRcdFx0XHRcdCkgKiBpdGVtV2lkdGg7XG5cdFx0XHRcdFx0aWYgKG1heFNjcm9sbFggIT09IDApIHtcblx0XHRcdFx0XHRcdGlmICh4ID4gMCkge1xuXHRcdFx0XHRcdFx0XHRzbmFwUG9pbnQgPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh4IDwgbWF4U2Nyb2xsWCkge1xuXHRcdFx0XHRcdFx0XHRzbmFwUG9pbnQgPSBtYXhTY3JvbGxYO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRoZWxwZXIudGljaztcblx0XHRcdH0pLFxuXHRcdFx0c3RvcDogaGVscGVyLnN0b3AsXG5cdFx0fTtcblx0fSkoKTtcblxuXHQvKipcblx0ICogRGVmaW5lcyBpZiB3ZSBzaG91bGQgc3ByaW5nIG9yIGRlY2F5IGJhc2VkIG9uIG1heFNjcm9sbFguXG5cdCAqKi9cblx0Y29uc3Qgc2hvdWxkU3ByaW5nSW5zdGVhZE9mRGVjYXkgPSByZSgoKSA9PiB7XG5cdFx0aWYgKG1heFNjcm9sbFggPT09IDApIHtcblx0XHRcdDA7XG5cdFx0fSBlbHNlIGlmICh4ID4gMCkge1xuXHRcdFx0MTtcblx0XHR9IGVsc2UgaWYgKHggPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHQxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQwO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgZGVjYXkgcmVsYXRlZCBzdHVmZi5cblx0ICoqL1xuXHRjb25zdCBkZWNheVN0YXRlID0gKCgpID0+IHtcblx0XHRjb25zdCBoZWxwZXIgPSBkZWNheUhlbHBlcih4LCB2ZWxvY2l0eSwgMC45OTcpO1xuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgaWYgdGhlIGRlY2F5IGVuZGVkIHVwIGdvaW5nIHBhc3Qgb3VyIG1pbi9tYXggeCAoaWYgc2V0KVxuXHRcdCAqKi9cblx0XHRsZXQgb3ZlcnNob3QgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdC4uLmhlbHBlcixcblx0XHRcdG92ZXJzaG90LFxuXHRcdFx0dGljazogcmUoKCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSdyZSBub3QgcnVubmluZyAscmVzZXQgc3R1ZmYuXG5cdFx0XHRcdGlmIChoZWxwZXIucnVubmluZyA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIFJlc2V0IG92ZXJzaG90IHRvIDBcblx0XHRcdFx0XHRvdmVyc2hvdCA9IDA7XG5cdFx0XHRcdFx0aGVscGVyLnRpY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKG1heFNjcm9sbFggIT09IDAgJiYgKHggPiAwIHx8IHggPCBtYXhTY3JvbGxYKSkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIG1heFNjcm9sbCBzZXQgYW5kIHdlIHdlbnQgcGFzc2VkIGl0LCBzZXQgb3ZlcnNob3QgdG8gMS5cblx0XHRcdFx0XHRcdG92ZXJzaG90ID0gMTtcblx0XHRcdFx0XHRcdC8vIFNldCBvdXIgdmVsb2NpdHkgdG8gdGhlIGRlY2F5J3MuXG5cdFx0XHRcdFx0XHR2ZWxvY2l0eSA9IGhlbHBlci52ZWxvY2l0eTtcblx0XHRcdFx0XHRcdGhlbHBlci5zdG9wO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRoZWxwZXIudGljaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdH07XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgZXZlcnl0aGluZyByZWxhdGVkIHRvIGdlc3R1cmVzXG5cdCAqKi9cblx0Y29uc3QgZ2VzdHVyZVN0YXRlID0gKCgpID0+IHtcblx0XHRsZXQgbmV3WCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgcG9pbnRYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBkaXN0WCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgZGVsdGFYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBzdGFydFRpbWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IGVuZFRpbWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0XHRsZXQgZGF0YSA9IHtcblx0XHRcdHg6IG5ldyBBbmltYXRlZC5WYWx1ZSgwKSxcblx0XHRcdHN0YXRlOiBuZXcgQW5pbWF0ZWQuVmFsdWUoLTEpLFxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSBnZXN0dXJlIHN0YXJ0cy5cblx0XHQgKiovXG5cdFx0bGV0IHN0YXJ0ID0gcmUoKCkgPT4ge1xuXHRcdFx0c3RhcnRDbG9jayhiYXNlQ2xvY2spO1xuXHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuR0VTVFVSRTtcblx0XHRcdGRpc3RYID0gMDtcblx0XHRcdHN0YXJ0VGltZSA9IGJhc2VDbG9jaztcblx0XHRcdHBvaW50WCA9IGRhdGEueDtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGdlc3R1cmUgbW92ZS5cblx0XHQgKiovXG5cdFx0bGV0IG1vdmUgPSByZSgoKSA9PiB7XG5cdFx0XHRkZWx0YVggPSBkYXRhLnggLSBwb2ludFg7XG5cblx0XHRcdHBvaW50WCA9IGRhdGEueDtcblx0XHRcdGRpc3RYID0gZGlzdFggKyBkZWx0YVg7XG5cdFx0XHRuZXdYID0geCArIGRlbHRhWDtcblx0XHRcdGlmIChtYXhTY3JvbGxYICE9PSAwKSB7XG5cdFx0XHRcdGlmIChuZXdYID4gMCB8fCBuZXdYIDwgbWF4U2Nyb2xsWCkge1xuXHRcdFx0XHRcdG5ld1ggPSB4ICsgZGVsdGFYIC8gMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0eCA9IG5ld1g7XG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciBnZXN0dXJlIGVuZFxuXHRcdCAqKi9cblx0XHRsZXQgZW5kID0gcmUoKCkgPT4ge1xuXHRcdFx0c3RvcENsb2NrKGJhc2VDbG9jayk7XG5cdFx0XHRlbmRUaW1lID0gYmFzZUNsb2NrO1xuXHRcdFx0dmVsb2NpdHkgPSAoZGlzdFggLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkpICogMTAwMDtcblx0XHRcdGlmIChzaG91bGRTcHJpbmdJbnN0ZWFkT2ZEZWNheSA9PT0gMCkge1xuXHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5ERUNBWTtcblx0XHRcdFx0ZGVjYXlTdGF0ZS50aWNrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuU1BSSU5HO1xuXHRcdFx0XHRzcHJpbmdTdGF0ZS50aWNrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHtkYXRhLCBzdGFydCwgbW92ZSwgZW5kfTtcblx0fSkoKTtcblxuXHQvKipcblx0ICogUHJpbWFyeSBsb2dpYyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB4YC5cblx0ICoqL1xuXHRjb25zdCBjYWxjdWxhdGVkVHJhbnNYID0gcmUoKCkgPT4ge1xuXHRcdGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLklETEUpIHtcblx0XHRcdC8vIFdlJ3ZlIHN0YXJ0ZWQgc2Nyb2xsaW5nXG5cdFx0XHRpZiAoZ2VzdHVyZVN0YXRlLmRhdGEuc3RhdGUgPT09IFN0YXRlLkFDVElWRSkge1xuXHRcdFx0XHRnZXN0dXJlU3RhdGUuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLkdFU1RVUkUpIHtcblx0XHRcdC8vIFdlJ3JlIHN0aWxsIHNjcm9sbGluZ1xuXHRcdFx0aWYgKGdlc3R1cmVTdGF0ZS5kYXRhLnN0YXRlID09PSBTdGF0ZS5BQ1RJVkUpIHtcblx0XHRcdFx0Z2VzdHVyZVN0YXRlLm1vdmU7XG5cdFx0XHR9XG5cdFx0XHQvLyBTY3JvbGxpbmcgaGFzIGVuZGVkXG5cdFx0XHRlbHNlIGlmIChnZXN0dXJlU3RhdGUuZGF0YS5zdGF0ZSA9PT0gU3RhdGUuRU5EKSB7XG5cdFx0XHRcdGdlc3R1cmVTdGF0ZS5lbmQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIFdlJ3JlIG5vdCBpZGxlIGFuZCBzY3JvbGxpbmcgaXNuJ3QgYWN0aXZlXG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBXZSd2ZSBzdGFydGVkIHNjcm9sbGluZyBhZ2FpblxuXHRcdFx0aWYgKGdlc3R1cmVTdGF0ZS5kYXRhLnN0YXRlID09PSBTdGF0ZS5BQ1RJVkUpIHtcblx0XHRcdFx0ZGVjYXlTdGF0ZS5zdG9wO1xuXHRcdFx0XHRzcHJpbmdTdGF0ZS5zdG9wO1xuXHRcdFx0XHRnZXN0dXJlU3RhdGUuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSdyZSBpbiB0aGUgZGVjYXkgc3RhdGVcblx0XHRcdGVsc2UgaWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuREVDQVkpIHtcblx0XHRcdFx0c3ByaW5nU3RhdGUuc3RvcDtcblx0XHRcdFx0ZGVjYXlTdGF0ZS50aWNrO1xuXHRcdFx0XHRpZiAoZGVjYXlTdGF0ZS5maW5pc2hlZCA9PT0gMSkge1xuXHRcdFx0XHRcdGlmIChkZWNheVN0YXRlLm92ZXJzaG90ID09PSAwKSB7XG5cdFx0XHRcdFx0XHR2ZWxvY2l0eSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLlNQUklORztcblx0XHRcdFx0XHRzcHJpbmdTdGF0ZS50aWNrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSdyZSBpbiB0aGUgc3ByaW5nIHN0YXRlXG5cdFx0XHRlbHNlIGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLlNQUklORykge1xuXHRcdFx0XHRkZWNheVN0YXRlLnN0b3A7XG5cdFx0XHRcdHNwcmluZ1N0YXRlLnRpY2s7XG5cdFx0XHRcdGlmIChzcHJpbmdTdGF0ZS5maW5pc2hlZCA9PT0gMSkge1xuXHRcdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLklETEU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFdlJ3JlIGluIHRoZSBzY3JvbGwgdG8gc3RhdGVcblx0XHRcdGVsc2UgaWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuU0NST0xMX1RPKSB7XG5cdFx0XHRcdGlmIChzY3JvbGxUb1dpdGhBbmltYXRpb24gPT09IDApIHtcblx0XHRcdFx0XHRkZWNheVN0YXRlLnN0b3A7XG5cdFx0XHRcdFx0c3ByaW5nU3RhdGUuc3RvcDtcblx0XHRcdFx0XHR4ID0gc2Nyb2xsVG9WYWx1ZTtcblx0XHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5JRExFO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFNldCB2ZWxvY2l0eSB0byAwIHNpbmNlIHdlJ3JlIG5vdCBzY3JvbGxpbmdcblx0XHRcdFx0XHR2ZWxvY2l0eSA9IDA7XG5cdFx0XHRcdFx0Ly8gVGhpcyBjaGVja3MgaWYgdGhlIHNjcm9sbFRvVmFsdWUgY2hhbmdlZCwgb3IgaWYgdGhlIHN0YXRlIGNoYW5nZWQgZnJvbSBzcHJpbmcgdG8gc2Nyb2xsLlxuXHRcdFx0XHRcdGlmIChwcmV2aW91c0xvZ2ljU3RhdGUgIT09IGxvZ2ljU3RhdGUgfHwgZGlmZihzY3JvbGxUb1ZhbHVlKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gU3RvcCBldmVyeXRoaW5nLCByZXNldHRpbmcgaXRcblx0XHRcdFx0XHRcdGRlY2F5U3RhdGUuc3RvcDtcblx0XHRcdFx0XHRcdHNwcmluZ1N0YXRlLnN0b3A7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNwcmluZ1N0YXRlLnRpY2s7XG5cdFx0XHRcdFx0aWYgKHNwcmluZ1N0YXRlLmZpbmlzaGVkID09PSAxKSB7XG5cdFx0XHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5JRExFO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBTY3JvbGwgaGFzIGVuZGVkXG5cdFx0aWYgKGRpZmYobG9naWNTdGF0ZSkgIT09IDAgJiYgbG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5JRExFKSB7XG5cdFx0XHRjYWxsKFt4V2l0aENlbnRlciwgbG9naWNTdGF0ZV0sIG9uU2Nyb2xsRW5kKTtcblx0XHR9XG5cdFx0Ly8gWCBoYXMgY2hhbmdlZFxuXHRcdGNhbGwoW3hXaXRoQ2VudGVyXSwgb25YQ2hhbmdlKTtcblx0XHRwcmV2aW91c0xvZ2ljU3RhdGUgPSBsb2dpY1N0YXRlO1xuXHRcdHhXaXRoQ2VudGVyO1xuXHR9KTtcblxuXHRjb25zdCBnZXN0dXJlSGFuZGxlciA9IEFuaW1hdGVkLmV2ZW50KFtcblx0XHR7XG5cdFx0XHRuYXRpdmVFdmVudDogZ2VzdHVyZVN0YXRlLmRhdGEsXG5cdFx0fSxcblx0XSk7XG5cblx0Y29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShldmVudEVtaXR0ZXIpO1xuXG5cdE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7XG5cdFx0eDogY2FsY3VsYXRlZFRyYW5zWCxcblx0XHRnZXN0dXJlSGFuZGxlcixcblx0XHR1cGRhdGVJdGVtV2lkdGgodmFsdWUpIHtcblx0XHRcdGl0ZW1XaWR0aC5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0fSxcblx0XHR1cGRhdGVXcmFwcGVyV2lkdGgodmFsdWUpIHtcblx0XHRcdHdyYXBwZXJXaWR0aC5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0fSxcblx0XHR1cGRhdGVDZW50ZXJTY3JvbGwodmFsdWUpIHtcblx0XHRcdGNlbnRlclNjcm9sbC5zZXRWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcblx0XHR9LFxuXHRcdHVwZGF0ZU1heFNjcm9sbCh2YWx1ZSkge1xuXHRcdFx0bWF4U2Nyb2xsWC5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0fSxcblx0XHRzY3JvbGxUbyh2YWx1ZSwgd2l0aEFuaW1hdGlvbiA9IHRydWUpIHtcblx0XHRcdHNjcm9sbFRvVmFsdWUuc2V0VmFsdWUodmFsdWUpO1xuXHRcdFx0c2Nyb2xsVG9XaXRoQW5pbWF0aW9uLnNldFZhbHVlKHdpdGhBbmltYXRpb24gPyAxIDogMCk7XG5cdFx0XHRsb2dpY1N0YXRlLnNldFZhbHVlKExvZ2ljU3RhdGUuU0NST0xMX1RPKTtcblx0XHR9LFxuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuIl19