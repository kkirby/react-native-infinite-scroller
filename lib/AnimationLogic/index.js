function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @ts-nocheck
import { State } from 'react-native-gesture-handler';
import EventEmitter from 'events';
import { decayHelper, springHelper } from './ReanimatedHelpers';
import Animated from 'react-native-reanimated';
const {
  call,
  stopClock,
  startClock,
  diff,
  debug,
  abs,
  round
} = Animated;
const LogicState = {
  IDLE: 0,
  DECAY: 1,
  SPRING: 2,
  GESTURE: 3,
  SCROLL_TO: 4
};

function getOr(value, defaultValue) {
  if (value != null) {
    return value;
  } else {
    return defaultValue;
  }
}

export default function AnimationLogic(options = {}) {
  const {
    springConfig,
    decayConfig
  } = options;
  const eventEmitter = new EventEmitter();
  /**
   * This is used to determine velocity. The clock is started and stopped,
   * and the time in between start and stops is used to calculate velocity.
   **/

  let baseClock = new Animated.Clock();
  /**
   * Stores the current state of our primary logic
   **/

  let logicState = new Animated.Value(LogicState.IDLE);
  let previousLogicState = new Animated.Value(LogicState.IDLE);
  let x = new Animated.Value(getOr(options.startingPosition, 0));
  let velocity = new Animated.Value(0);
  let itemWidth = new Animated.Value(getOr(options.itemWidth, 0));
  let wrapperWidth = new Animated.Value(getOr(options.wrapperWidth, 0));
  /**
   * Holds the center offset
   **/

  let center = Animated.divide(Animated.add(wrapperWidth, itemWidth), 2);
  let centerScroll = new Animated.Value(getOr(options.centerScroll, false) ? 1 : 0);
  /**
   * Holds the value of X + the center offset (if centerScroll is 1).
   **/

  let xWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(x, center), itemWidth)], [x])]);
  let maxScrollX = new Animated.Value(getOr(options.maxScroll, 0));
  let hasMaxScrollX = new Animated.Value(getOr(options.hasMaxScroll, 0));
  /**
   * Holds the destination scroll value when `scrollTo` is called.
   **/

  let scrollToValue = new Animated.Value(0);
  /**
   * Holds wether or not the scroll to should be animated.
   **/

  let scrollToWithAnimation = new Animated.Value(0);
  /**
   *
   **/

  let springToNextItemInDirection = new Animated.Value(0);
  /**
   * Handler for when the x value changes.
   **/

  const onXChange = value => {
    eventEmitter.emit('change', value[0]);
  };
  /**
   * Handler for when the scroll ends.
   **/


  const onScrollEnd = ([scrollEndXWithCenter, scrollEndX]) => {
    eventEmitter.emit('scrollEnd', {
      xWithCenter: scrollEndXWithCenter,
      x: scrollEndX
    });
  };
  /**
   * Handler for when the scroll has settled and no more animations are playing.
   **/


  const onScrollSettled = value => {
    eventEmitter.emit('scrollSettled', value[0]);
  };
  /**
   * Handles spring related stuff.
   **/


  const springState = (() => {
    let snapPoint = new Animated.Value(0);
    let snapPointWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(snapPoint, center), itemWidth)], [snapPoint])]);
    const helper = springHelper(x, snapPoint, velocity, springConfig);
    return _objectSpread({}, helper, {
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(snapPoint, Animated.multiply(round(Animated.divide([Animated.cond(Animated.eq(logicState, LogicState.SPRING), [Animated.cond(Animated.neq(springToNextItemInDirection, 0), [Animated.add(x, Animated.multiply(itemWidth, springToNextItemInDirection))], [x])], [scrollToValue])], itemWidth)), itemWidth)), Animated.cond(Animated.eq(hasMaxScrollX, 1), [Animated.cond(Animated.greaterThan(snapPoint, 0), [Animated.set(snapPoint, 0)], Animated.cond(Animated.lessThan(snapPoint, maxScrollX), [Animated.set(snapPoint, maxScrollX)]))]), call([snapPointWithCenter, snapPoint], onScrollEnd)]), helper.tick]),
      stop: helper.stop
    });
  })();
  /**
   * Defines if we should spring or decay based on maxScrollX.
   **/


  const shouldSpringInsteadOfDecay = Animated.block([Animated.cond(Animated.eq(hasMaxScrollX, 0), [0], Animated.cond(Animated.greaterThan(x, 0), [1], Animated.cond(Animated.lessThan(x, maxScrollX), [1], [0])))]);
  /**
   * Handles decay related stuff.
   **/

  const decayState = (() => {
    const helper = decayHelper(x, velocity, decayConfig && decayConfig.deceleration ? decayConfig.deceleration : 0.997);
    /**
     * Defines if the decay ended up going past our min/max x (if set)
     **/

    let overshot = new Animated.Value(0);
    return _objectSpread({}, helper, {
      overshot,
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(overshot, 0), helper.tick], [Animated.cond(Animated.and(Animated.eq(hasMaxScrollX, 1), Animated.or(Animated.greaterThan(x, 0), Animated.lessThan(x, maxScrollX))), [Animated.set(overshot, 1), Animated.set(velocity, helper.velocity), helper.stop], [helper.tick])])])
    });
  })();
  /**
   * Handles everything related to gestures
   **/


  const gestureState = (() => {
    let newX = new Animated.Value(0);
    let pointX = new Animated.Value(0);
    let distX = new Animated.Value(0);
    let deltaX = new Animated.Value(0);
    let startTime = new Animated.Value(0);
    let endTime = new Animated.Value(0);
    let data = {
      x: new Animated.Value(0),
      state: new Animated.Value(-1),
      velocityX: new Animated.Value(0)
    };
    /**
     * Handler for when the gesture starts.
     **/

    let start = Animated.block([startClock(baseClock), Animated.set(logicState, LogicState.GESTURE), Animated.set(distX, 0), Animated.set(startTime, baseClock), Animated.set(pointX, data.x)]);
    /**
     * Handler for gesture move.
     **/

    let move = Animated.block([Animated.set(deltaX, Animated.sub(data.x, pointX)), Animated.set(pointX, data.x), Animated.set(distX, Animated.add(distX, deltaX)), Animated.set(newX, Animated.add(x, deltaX)), Animated.cond(Animated.eq(hasMaxScrollX, 1), [Animated.cond(Animated.or(Animated.greaterThan(newX, 0), Animated.lessThan(newX, maxScrollX)), [Animated.set(newX, Animated.add(x, Animated.divide(deltaX, 3)))])]), Animated.set(x, newX)]);
    /**
     * Handler for gesture end
     **/

    let end = Animated.block([stopClock(baseClock), Animated.set(endTime, baseClock), Animated.set(velocity, data.velocityX), Animated.cond(Animated.or(Animated.eq(shouldSpringInsteadOfDecay, 1), Animated.lessThan(abs(velocity), 3000)), [Animated.cond(Animated.greaterThan(abs(velocity), 0), [Animated.set(springToNextItemInDirection, Animated.divide(abs(velocity), velocity))], [Animated.set(springToNextItemInDirection, 0)]), Animated.set(logicState, LogicState.SPRING), springState.tick], [Animated.set(springToNextItemInDirection, 0), Animated.set(logicState, LogicState.DECAY), decayState.tick])]);
    return {
      data,
      start,
      move,
      end
    };
  })();
  /**
   * Primary logic to determine the value of `x`.
   **/


  const calculatedTransX = Animated.block([Animated.cond(Animated.eq(logicState, LogicState.IDLE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.start])], Animated.cond(Animated.eq(logicState, LogicState.GESTURE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.move], Animated.cond(Animated.eq(gestureState.data.state, State.END), [gestureState.end]))], [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [decayState.stop, springState.stop, gestureState.start], Animated.cond(Animated.eq(logicState, LogicState.DECAY), [springState.stop, decayState.tick, Animated.cond(Animated.eq(decayState.finished, 1), [Animated.cond(Animated.eq(decayState.overshot, 0), [Animated.set(velocity, 0)]), Animated.set(logicState, LogicState.SPRING), springState.tick])], Animated.cond(Animated.eq(logicState, LogicState.SPRING), [decayState.stop, springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])], Animated.cond(Animated.eq(logicState, LogicState.SCROLL_TO), [Animated.cond(Animated.eq(scrollToWithAnimation, 0), [decayState.stop, springState.stop, Animated.set(x, scrollToValue), Animated.set(logicState, LogicState.IDLE), call([xWithCenter, x], onScrollEnd)], [Animated.set(velocity, 0), Animated.cond(Animated.or(Animated.neq(diff(scrollToValue), 0), Animated.neq(previousLogicState, logicState)), [decayState.stop, springState.stop]), springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])])]))))])), Animated.cond(Animated.and(Animated.neq(diff(logicState), 0), Animated.eq(logicState, LogicState.IDLE)), [call([xWithCenter, logicState], onScrollSettled)]), call([xWithCenter], onXChange), Animated.set(previousLogicState, logicState), xWithCenter]);
  const gestureHandler = Animated.event([{
    nativeEvent: gestureState.data
  }]);
  const result = Object.create(eventEmitter);
  Object.assign(result, {
    x: calculatedTransX,
    gestureHandler,

    updateItemWidth(value) {
      itemWidth.setValue(value);
    },

    updateWrapperWidth(value) {
      wrapperWidth.setValue(value);
    },

    updateCenterScroll(value) {
      centerScroll.setValue(value ? 1 : 0);
    },

    updateMaxScroll(value) {
      if (value != null) {
        hasMaxScrollX.setValue(1);
        maxScrollX.setValue(value);
      } else {
        hasMaxScrollX.setValue(0);
        maxScrollX.setValue(0);
      }
    },

    scrollTo(value, withAnimation = true) {
      scrollToValue.setValue(value);
      scrollToWithAnimation.setValue(withAnimation ? 1 : 0);
      logicState.setValue(LogicState.SCROLL_TO);
    }

  });
  return result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTdGF0ZSIsIkV2ZW50RW1pdHRlciIsImRlY2F5SGVscGVyIiwic3ByaW5nSGVscGVyIiwiQW5pbWF0ZWQiLCJjYWxsIiwic3RvcENsb2NrIiwic3RhcnRDbG9jayIsImRpZmYiLCJkZWJ1ZyIsImFicyIsInJvdW5kIiwiTG9naWNTdGF0ZSIsIklETEUiLCJERUNBWSIsIlNQUklORyIsIkdFU1RVUkUiLCJTQ1JPTExfVE8iLCJnZXRPciIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiQW5pbWF0aW9uTG9naWMiLCJvcHRpb25zIiwic3ByaW5nQ29uZmlnIiwiZGVjYXlDb25maWciLCJldmVudEVtaXR0ZXIiLCJiYXNlQ2xvY2siLCJDbG9jayIsImxvZ2ljU3RhdGUiLCJWYWx1ZSIsInByZXZpb3VzTG9naWNTdGF0ZSIsIngiLCJzdGFydGluZ1Bvc2l0aW9uIiwidmVsb2NpdHkiLCJpdGVtV2lkdGgiLCJ3cmFwcGVyV2lkdGgiLCJjZW50ZXIiLCJjZW50ZXJTY3JvbGwiLCJ4V2l0aENlbnRlciIsIm1heFNjcm9sbFgiLCJtYXhTY3JvbGwiLCJoYXNNYXhTY3JvbGxYIiwiaGFzTWF4U2Nyb2xsIiwic2Nyb2xsVG9WYWx1ZSIsInNjcm9sbFRvV2l0aEFuaW1hdGlvbiIsInNwcmluZ1RvTmV4dEl0ZW1JbkRpcmVjdGlvbiIsIm9uWENoYW5nZSIsImVtaXQiLCJvblNjcm9sbEVuZCIsInNjcm9sbEVuZFhXaXRoQ2VudGVyIiwic2Nyb2xsRW5kWCIsIm9uU2Nyb2xsU2V0dGxlZCIsInNwcmluZ1N0YXRlIiwic25hcFBvaW50Iiwic25hcFBvaW50V2l0aENlbnRlciIsImhlbHBlciIsInRpY2siLCJydW5uaW5nIiwic3RvcCIsInNob3VsZFNwcmluZ0luc3RlYWRPZkRlY2F5IiwiZGVjYXlTdGF0ZSIsImRlY2VsZXJhdGlvbiIsIm92ZXJzaG90IiwiZ2VzdHVyZVN0YXRlIiwibmV3WCIsInBvaW50WCIsImRpc3RYIiwiZGVsdGFYIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImRhdGEiLCJzdGF0ZSIsInZlbG9jaXR5WCIsInN0YXJ0IiwibW92ZSIsImVuZCIsImNhbGN1bGF0ZWRUcmFuc1giLCJBQ1RJVkUiLCJFTkQiLCJmaW5pc2hlZCIsImdlc3R1cmVIYW5kbGVyIiwiZXZlbnQiLCJuYXRpdmVFdmVudCIsInJlc3VsdCIsIk9iamVjdCIsImNyZWF0ZSIsImFzc2lnbiIsInVwZGF0ZUl0ZW1XaWR0aCIsInNldFZhbHVlIiwidXBkYXRlV3JhcHBlcldpZHRoIiwidXBkYXRlQ2VudGVyU2Nyb2xsIiwidXBkYXRlTWF4U2Nyb2xsIiwic2Nyb2xsVG8iLCJ3aXRoQW5pbWF0aW9uIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL0FuaW1hdGlvbkxvZ2ljL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG5cbmltcG9ydCByZSBmcm9tICdAa2tpcmJhdHNraS9qcy10by1yZWFuaW1hdGVkLm1hY3JvJztcbmltcG9ydCB7U3RhdGV9IGZyb20gJ3JlYWN0LW5hdGl2ZS1nZXN0dXJlLWhhbmRsZXInO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtkZWNheUhlbHBlciwgc3ByaW5nSGVscGVyfSBmcm9tICcuL1JlYW5pbWF0ZWRIZWxwZXJzJztcbmltcG9ydCBBbmltYXRlZCBmcm9tICdyZWFjdC1uYXRpdmUtcmVhbmltYXRlZCc7XG5jb25zdCB7Y2FsbCwgc3RvcENsb2NrLCBzdGFydENsb2NrLCBkaWZmLCBkZWJ1ZywgYWJzLCByb3VuZH0gPSBBbmltYXRlZDtcblxuY29uc3QgTG9naWNTdGF0ZSA9IHtcblx0SURMRTogMCxcblx0REVDQVk6IDEsXG5cdFNQUklORzogMixcblx0R0VTVFVSRTogMyxcblx0U0NST0xMX1RPOiA0LFxufTtcblxuZnVuY3Rpb24gZ2V0T3IodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFuaW1hdGlvbkxvZ2ljKG9wdGlvbnMgPSB7fSkge1xuXHRjb25zdCB7c3ByaW5nQ29uZmlnLCBkZWNheUNvbmZpZ30gPSBvcHRpb25zO1xuXHRjb25zdCBldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdC8qKlxuXHQgKiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHZlbG9jaXR5LiBUaGUgY2xvY2sgaXMgc3RhcnRlZCBhbmQgc3RvcHBlZCxcblx0ICogYW5kIHRoZSB0aW1lIGluIGJldHdlZW4gc3RhcnQgYW5kIHN0b3BzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHZlbG9jaXR5LlxuXHQgKiovXG5cdGxldCBiYXNlQ2xvY2sgPSBuZXcgQW5pbWF0ZWQuQ2xvY2soKTtcblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBvdXIgcHJpbWFyeSBsb2dpY1xuXHQgKiovXG5cdGxldCBsb2dpY1N0YXRlID0gbmV3IEFuaW1hdGVkLlZhbHVlKExvZ2ljU3RhdGUuSURMRSk7XG5cdGxldCBwcmV2aW91c0xvZ2ljU3RhdGUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoTG9naWNTdGF0ZS5JRExFKTtcblxuXHRsZXQgeCA9IG5ldyBBbmltYXRlZC5WYWx1ZShnZXRPcihvcHRpb25zLnN0YXJ0aW5nUG9zaXRpb24sIDApKTtcblx0bGV0IHZlbG9jaXR5ID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdGxldCBpdGVtV2lkdGggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoZ2V0T3Iob3B0aW9ucy5pdGVtV2lkdGgsIDApKTtcblx0bGV0IHdyYXBwZXJXaWR0aCA9IG5ldyBBbmltYXRlZC5WYWx1ZShnZXRPcihvcHRpb25zLndyYXBwZXJXaWR0aCwgMCkpO1xuXG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgY2VudGVyIG9mZnNldFxuXHQgKiovXG5cdGxldCBjZW50ZXIgPSByZSgod3JhcHBlcldpZHRoICsgaXRlbVdpZHRoKSAvIDIpO1xuXHRsZXQgY2VudGVyU2Nyb2xsID0gbmV3IEFuaW1hdGVkLlZhbHVlKFxuXHRcdGdldE9yKG9wdGlvbnMuY2VudGVyU2Nyb2xsLCBmYWxzZSkgPyAxIDogMCxcblx0KTtcblx0LyoqXG5cdCAqIEhvbGRzIHRoZSB2YWx1ZSBvZiBYICsgdGhlIGNlbnRlciBvZmZzZXQgKGlmIGNlbnRlclNjcm9sbCBpcyAxKS5cblx0ICoqL1xuXHRsZXQgeFdpdGhDZW50ZXIgPSByZSgoKSA9PiB7XG5cdFx0aWYgKGNlbnRlclNjcm9sbCA9PT0gMSkge1xuXHRcdFx0eCArIGNlbnRlciAtIGl0ZW1XaWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eDtcblx0XHR9XG5cdH0pO1xuXG5cdGxldCBtYXhTY3JvbGxYID0gbmV3IEFuaW1hdGVkLlZhbHVlKGdldE9yKG9wdGlvbnMubWF4U2Nyb2xsLCAwKSk7XG5cdGxldCBoYXNNYXhTY3JvbGxYID0gbmV3IEFuaW1hdGVkLlZhbHVlKGdldE9yKG9wdGlvbnMuaGFzTWF4U2Nyb2xsLCAwKSk7XG5cblx0LyoqXG5cdCAqIEhvbGRzIHRoZSBkZXN0aW5hdGlvbiBzY3JvbGwgdmFsdWUgd2hlbiBgc2Nyb2xsVG9gIGlzIGNhbGxlZC5cblx0ICoqL1xuXHRsZXQgc2Nyb2xsVG9WYWx1ZSA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHQvKipcblx0ICogSG9sZHMgd2V0aGVyIG9yIG5vdCB0aGUgc2Nyb2xsIHRvIHNob3VsZCBiZSBhbmltYXRlZC5cblx0ICoqL1xuXHRsZXQgc2Nyb2xsVG9XaXRoQW5pbWF0aW9uID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiovXG5cdGxldCBzcHJpbmdUb05leHRJdGVtSW5EaXJlY3Rpb24gPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIHggdmFsdWUgY2hhbmdlcy5cblx0ICoqL1xuXHRjb25zdCBvblhDaGFuZ2UgPSB2YWx1ZSA9PiB7XG5cdFx0ZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHZhbHVlWzBdKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlciBmb3Igd2hlbiB0aGUgc2Nyb2xsIGVuZHMuXG5cdCAqKi9cblx0Y29uc3Qgb25TY3JvbGxFbmQgPSAoW3Njcm9sbEVuZFhXaXRoQ2VudGVyLCBzY3JvbGxFbmRYXSkgPT4ge1xuXHRcdGV2ZW50RW1pdHRlci5lbWl0KCdzY3JvbGxFbmQnLCB7XG5cdFx0XHR4V2l0aENlbnRlcjogc2Nyb2xsRW5kWFdpdGhDZW50ZXIsXG5cdFx0XHR4OiBzY3JvbGxFbmRYLFxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSBzY3JvbGwgaGFzIHNldHRsZWQgYW5kIG5vIG1vcmUgYW5pbWF0aW9ucyBhcmUgcGxheWluZy5cblx0ICoqL1xuXHRjb25zdCBvblNjcm9sbFNldHRsZWQgPSB2YWx1ZSA9PiB7XG5cdFx0ZXZlbnRFbWl0dGVyLmVtaXQoJ3Njcm9sbFNldHRsZWQnLCB2YWx1ZVswXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgc3ByaW5nIHJlbGF0ZWQgc3R1ZmYuXG5cdCAqKi9cblx0Y29uc3Qgc3ByaW5nU3RhdGUgPSAoKCkgPT4ge1xuXHRcdGxldCBzbmFwUG9pbnQgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0XHRsZXQgc25hcFBvaW50V2l0aENlbnRlciA9IHJlKCgpID0+IHtcblx0XHRcdGlmIChjZW50ZXJTY3JvbGwgPT09IDEpIHtcblx0XHRcdFx0c25hcFBvaW50ICsgY2VudGVyIC0gaXRlbVdpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c25hcFBvaW50O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgaGVscGVyID0gc3ByaW5nSGVscGVyKHgsIHNuYXBQb2ludCwgdmVsb2NpdHksIHNwcmluZ0NvbmZpZyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Li4uaGVscGVyLFxuXHRcdFx0dGljazogcmUoKCkgPT4ge1xuXHRcdFx0XHRpZiAoaGVscGVyLnJ1bm5pbmcgPT09IDApIHtcblx0XHRcdFx0XHRzbmFwUG9pbnQgPVxuXHRcdFx0XHRcdFx0cm91bmQoXG5cdFx0XHRcdFx0XHRcdCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuU1BSSU5HKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3ByaW5nVG9OZXh0SXRlbUluRGlyZWN0aW9uICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHggK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGl0ZW1XaWR0aCAqXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzcHJpbmdUb05leHRJdGVtSW5EaXJlY3Rpb247XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4O1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzY3JvbGxUb1ZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSkgLyBpdGVtV2lkdGgsXG5cdFx0XHRcdFx0XHQpICogaXRlbVdpZHRoO1xuXHRcdFx0XHRcdGlmIChoYXNNYXhTY3JvbGxYID09PSAxKSB7XG5cdFx0XHRcdFx0XHRpZiAoc25hcFBvaW50ID4gMCkge1xuXHRcdFx0XHRcdFx0XHRzbmFwUG9pbnQgPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzbmFwUG9pbnQgPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHRcdFx0XHRcdHNuYXBQb2ludCA9IG1heFNjcm9sbFg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGwoW3NuYXBQb2ludFdpdGhDZW50ZXIsIHNuYXBQb2ludF0sIG9uU2Nyb2xsRW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoZWxwZXIudGljaztcblx0XHRcdH0pLFxuXHRcdFx0c3RvcDogaGVscGVyLnN0b3AsXG5cdFx0fTtcblx0fSkoKTtcblxuXHQvKipcblx0ICogRGVmaW5lcyBpZiB3ZSBzaG91bGQgc3ByaW5nIG9yIGRlY2F5IGJhc2VkIG9uIG1heFNjcm9sbFguXG5cdCAqKi9cblx0Y29uc3Qgc2hvdWxkU3ByaW5nSW5zdGVhZE9mRGVjYXkgPSByZSgoKSA9PiB7XG5cdFx0aWYgKGhhc01heFNjcm9sbFggPT09IDApIHtcblx0XHRcdDA7XG5cdFx0fSBlbHNlIGlmICh4ID4gMCkge1xuXHRcdFx0MTtcblx0XHR9IGVsc2UgaWYgKHggPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHQxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQwO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgZGVjYXkgcmVsYXRlZCBzdHVmZi5cblx0ICoqL1xuXHRjb25zdCBkZWNheVN0YXRlID0gKCgpID0+IHtcblx0XHRjb25zdCBoZWxwZXIgPSBkZWNheUhlbHBlcihcblx0XHRcdHgsXG5cdFx0XHR2ZWxvY2l0eSxcblx0XHRcdGRlY2F5Q29uZmlnICYmIGRlY2F5Q29uZmlnLmRlY2VsZXJhdGlvblxuXHRcdFx0XHQ/IGRlY2F5Q29uZmlnLmRlY2VsZXJhdGlvblxuXHRcdFx0XHQ6IDAuOTk3LFxuXHRcdCk7XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBpZiB0aGUgZGVjYXkgZW5kZWQgdXAgZ29pbmcgcGFzdCBvdXIgbWluL21heCB4IChpZiBzZXQpXG5cdFx0ICoqL1xuXHRcdGxldCBvdmVyc2hvdCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Li4uaGVscGVyLFxuXHRcdFx0b3ZlcnNob3QsXG5cdFx0XHR0aWNrOiByZSgoKSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBydW5uaW5nICxyZXNldCBzdHVmZi5cblx0XHRcdFx0aWYgKGhlbHBlci5ydW5uaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gUmVzZXQgb3ZlcnNob3QgdG8gMFxuXHRcdFx0XHRcdG92ZXJzaG90ID0gMDtcblx0XHRcdFx0XHRoZWxwZXIudGljaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaGFzTWF4U2Nyb2xsWCA9PT0gMSAmJiAoeCA+IDAgfHwgeCA8IG1heFNjcm9sbFgpKSB7XG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgbWF4U2Nyb2xsIHNldCBhbmQgd2Ugd2VudCBwYXNzZWQgaXQsIHNldCBvdmVyc2hvdCB0byAxLlxuXHRcdFx0XHRcdFx0b3ZlcnNob3QgPSAxO1xuXHRcdFx0XHRcdFx0Ly8gU2V0IG91ciB2ZWxvY2l0eSB0byB0aGUgZGVjYXkncy5cblx0XHRcdFx0XHRcdHZlbG9jaXR5ID0gaGVscGVyLnZlbG9jaXR5O1xuXHRcdFx0XHRcdFx0aGVscGVyLnN0b3A7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGhlbHBlci50aWNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0fTtcblx0fSkoKTtcblx0LyoqXG5cdCAqIEhhbmRsZXMgZXZlcnl0aGluZyByZWxhdGVkIHRvIGdlc3R1cmVzXG5cdCAqKi9cblx0Y29uc3QgZ2VzdHVyZVN0YXRlID0gKCgpID0+IHtcblx0XHRsZXQgbmV3WCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgcG9pbnRYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBkaXN0WCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgZGVsdGFYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBzdGFydFRpbWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IGVuZFRpbWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0XHRsZXQgZGF0YSA9IHtcblx0XHRcdHg6IG5ldyBBbmltYXRlZC5WYWx1ZSgwKSxcblx0XHRcdHN0YXRlOiBuZXcgQW5pbWF0ZWQuVmFsdWUoLTEpLFxuXHRcdFx0dmVsb2NpdHlYOiBuZXcgQW5pbWF0ZWQuVmFsdWUoMCksXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLlxuXHRcdCAqKi9cblx0XHRsZXQgc3RhcnQgPSByZSgoKSA9PiB7XG5cdFx0XHRzdGFydENsb2NrKGJhc2VDbG9jayk7XG5cdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5HRVNUVVJFO1xuXHRcdFx0ZGlzdFggPSAwO1xuXHRcdFx0c3RhcnRUaW1lID0gYmFzZUNsb2NrO1xuXHRcdFx0cG9pbnRYID0gZGF0YS54O1xuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgZ2VzdHVyZSBtb3ZlLlxuXHRcdCAqKi9cblx0XHRsZXQgbW92ZSA9IHJlKCgpID0+IHtcblx0XHRcdGRlbHRhWCA9IGRhdGEueCAtIHBvaW50WDtcblxuXHRcdFx0cG9pbnRYID0gZGF0YS54O1xuXHRcdFx0ZGlzdFggPSBkaXN0WCArIGRlbHRhWDtcblx0XHRcdG5ld1ggPSB4ICsgZGVsdGFYO1xuXHRcdFx0Ly8gVGhpcyB3aWxsIGdpdmUgYW4gZWxhc3RpYyBmZWVsIHdoZW4gb3Zlci1zY3JvbGxpbmcsIGFkZGluZyByZXNpc3RhbmNlIHRvIHRoZSBwdWxsLlxuXHRcdFx0aWYgKGhhc01heFNjcm9sbFggPT09IDEpIHtcblx0XHRcdFx0aWYgKG5ld1ggPiAwIHx8IG5ld1ggPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHRcdFx0bmV3WCA9IHggKyBkZWx0YVggLyAzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR4ID0gbmV3WDtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGdlc3R1cmUgZW5kXG5cdFx0ICoqL1xuXHRcdGxldCBlbmQgPSByZSgoKSA9PiB7XG5cdFx0XHRzdG9wQ2xvY2soYmFzZUNsb2NrKTtcblx0XHRcdGVuZFRpbWUgPSBiYXNlQ2xvY2s7XG5cdFx0XHR2ZWxvY2l0eSA9IGRhdGEudmVsb2NpdHlYO1xuXHRcdFx0aWYgKHNob3VsZFNwcmluZ0luc3RlYWRPZkRlY2F5ID09PSAxIHx8IGFicyh2ZWxvY2l0eSkgPCAzMDAwKSB7XG5cdFx0XHRcdGlmIChhYnModmVsb2NpdHkpID4gMCkge1xuXHRcdFx0XHRcdHNwcmluZ1RvTmV4dEl0ZW1JbkRpcmVjdGlvbiA9IGFicyh2ZWxvY2l0eSkgLyB2ZWxvY2l0eTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzcHJpbmdUb05leHRJdGVtSW5EaXJlY3Rpb24gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLlNQUklORztcblx0XHRcdFx0c3ByaW5nU3RhdGUudGljaztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNwcmluZ1RvTmV4dEl0ZW1JbkRpcmVjdGlvbiA9IDA7XG5cdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLkRFQ0FZO1xuXHRcdFx0XHRkZWNheVN0YXRlLnRpY2s7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4ge2RhdGEsIHN0YXJ0LCBtb3ZlLCBlbmR9O1xuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBQcmltYXJ5IGxvZ2ljIHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHhgLlxuXHQgKiovXG5cdGNvbnN0IGNhbGN1bGF0ZWRUcmFuc1ggPSByZSgoKSA9PiB7XG5cdFx0aWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuSURMRSkge1xuXHRcdFx0Ly8gV2UndmUgc3RhcnRlZCBzY3JvbGxpbmdcblx0XHRcdGlmIChnZXN0dXJlU3RhdGUuZGF0YS5zdGF0ZSA9PT0gU3RhdGUuQUNUSVZFKSB7XG5cdFx0XHRcdGdlc3R1cmVTdGF0ZS5zdGFydDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuR0VTVFVSRSkge1xuXHRcdFx0Ly8gV2UncmUgc3RpbGwgc2Nyb2xsaW5nXG5cdFx0XHRpZiAoZ2VzdHVyZVN0YXRlLmRhdGEuc3RhdGUgPT09IFN0YXRlLkFDVElWRSkge1xuXHRcdFx0XHRnZXN0dXJlU3RhdGUubW92ZTtcblx0XHRcdH1cblx0XHRcdC8vIFNjcm9sbGluZyBoYXMgZW5kZWRcblx0XHRcdGVsc2UgaWYgKGdlc3R1cmVTdGF0ZS5kYXRhLnN0YXRlID09PSBTdGF0ZS5FTkQpIHtcblx0XHRcdFx0Z2VzdHVyZVN0YXRlLmVuZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gV2UncmUgbm90IGlkbGUgYW5kIHNjcm9sbGluZyBpc24ndCBhY3RpdmVcblx0XHRlbHNlIHtcblx0XHRcdC8vIFdlJ3ZlIHN0YXJ0ZWQgc2Nyb2xsaW5nIGFnYWluXG5cdFx0XHRpZiAoZ2VzdHVyZVN0YXRlLmRhdGEuc3RhdGUgPT09IFN0YXRlLkFDVElWRSkge1xuXHRcdFx0XHRkZWNheVN0YXRlLnN0b3A7XG5cdFx0XHRcdHNwcmluZ1N0YXRlLnN0b3A7XG5cdFx0XHRcdGdlc3R1cmVTdGF0ZS5zdGFydDtcblx0XHRcdH1cblx0XHRcdC8vIFdlJ3JlIGluIHRoZSBkZWNheSBzdGF0ZVxuXHRcdFx0ZWxzZSBpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5ERUNBWSkge1xuXHRcdFx0XHRzcHJpbmdTdGF0ZS5zdG9wO1xuXHRcdFx0XHRkZWNheVN0YXRlLnRpY2s7XG5cdFx0XHRcdGlmIChkZWNheVN0YXRlLmZpbmlzaGVkID09PSAxKSB7XG5cdFx0XHRcdFx0aWYgKGRlY2F5U3RhdGUub3ZlcnNob3QgPT09IDApIHtcblx0XHRcdFx0XHRcdHZlbG9jaXR5ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuU1BSSU5HO1xuXHRcdFx0XHRcdHNwcmluZ1N0YXRlLnRpY2s7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFdlJ3JlIGluIHRoZSBzcHJpbmcgc3RhdGVcblx0XHRcdGVsc2UgaWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuU1BSSU5HKSB7XG5cdFx0XHRcdGRlY2F5U3RhdGUuc3RvcDtcblx0XHRcdFx0c3ByaW5nU3RhdGUudGljaztcblx0XHRcdFx0aWYgKHNwcmluZ1N0YXRlLmZpbmlzaGVkID09PSAxKSB7XG5cdFx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuSURMRTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gV2UncmUgaW4gdGhlIHNjcm9sbCB0byBzdGF0ZVxuXHRcdFx0ZWxzZSBpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5TQ1JPTExfVE8pIHtcblx0XHRcdFx0aWYgKHNjcm9sbFRvV2l0aEFuaW1hdGlvbiA9PT0gMCkge1xuXHRcdFx0XHRcdGRlY2F5U3RhdGUuc3RvcDtcblx0XHRcdFx0XHRzcHJpbmdTdGF0ZS5zdG9wO1xuXHRcdFx0XHRcdHggPSBzY3JvbGxUb1ZhbHVlO1xuXHRcdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLklETEU7XG5cdFx0XHRcdFx0Y2FsbChbeFdpdGhDZW50ZXIsIHhdLCBvblNjcm9sbEVuZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gU2V0IHZlbG9jaXR5IHRvIDAgc2luY2Ugd2UncmUgbm90IHNjcm9sbGluZ1xuXHRcdFx0XHRcdHZlbG9jaXR5ID0gMDtcblx0XHRcdFx0XHQvLyBUaGlzIGNoZWNrcyBpZiB0aGUgc2Nyb2xsVG9WYWx1ZSBjaGFuZ2VkLCBvciBpZiB0aGUgc3RhdGUgY2hhbmdlZCBmcm9tIHNwcmluZyB0byBzY3JvbGwuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0ZGlmZihzY3JvbGxUb1ZhbHVlKSAhPT0gMCB8fFxuXHRcdFx0XHRcdFx0cHJldmlvdXNMb2dpY1N0YXRlICE9PSBsb2dpY1N0YXRlXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQvLyBTdG9wIGV2ZXJ5dGhpbmcsIHJlc2V0dGluZyBpdFxuXHRcdFx0XHRcdFx0ZGVjYXlTdGF0ZS5zdG9wO1xuXHRcdFx0XHRcdFx0c3ByaW5nU3RhdGUuc3RvcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3ByaW5nU3RhdGUudGljaztcblx0XHRcdFx0XHRpZiAoc3ByaW5nU3RhdGUuZmluaXNoZWQgPT09IDEpIHtcblx0XHRcdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLklETEU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIFNjcm9sbCBoYXMgc2V0dGxlZFxuXHRcdGlmIChkaWZmKGxvZ2ljU3RhdGUpICE9PSAwICYmIGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuSURMRSkge1xuXHRcdFx0Y2FsbChbeFdpdGhDZW50ZXIsIGxvZ2ljU3RhdGVdLCBvblNjcm9sbFNldHRsZWQpO1xuXHRcdH1cblx0XHQvLyBYIGhhcyBjaGFuZ2VkXG5cdFx0Y2FsbChbeFdpdGhDZW50ZXJdLCBvblhDaGFuZ2UpO1xuXHRcdHByZXZpb3VzTG9naWNTdGF0ZSA9IGxvZ2ljU3RhdGU7XG5cdFx0eFdpdGhDZW50ZXI7XG5cdH0pO1xuXG5cdGNvbnN0IGdlc3R1cmVIYW5kbGVyID0gQW5pbWF0ZWQuZXZlbnQoW1xuXHRcdHtcblx0XHRcdG5hdGl2ZUV2ZW50OiBnZXN0dXJlU3RhdGUuZGF0YSxcblx0XHR9LFxuXHRdKTtcblxuXHRjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKGV2ZW50RW1pdHRlcik7XG5cblx0T2JqZWN0LmFzc2lnbihyZXN1bHQsIHtcblx0XHR4OiBjYWxjdWxhdGVkVHJhbnNYLFxuXHRcdGdlc3R1cmVIYW5kbGVyLFxuXHRcdHVwZGF0ZUl0ZW1XaWR0aCh2YWx1ZSkge1xuXHRcdFx0aXRlbVdpZHRoLnNldFZhbHVlKHZhbHVlKTtcblx0XHR9LFxuXHRcdHVwZGF0ZVdyYXBwZXJXaWR0aCh2YWx1ZSkge1xuXHRcdFx0d3JhcHBlcldpZHRoLnNldFZhbHVlKHZhbHVlKTtcblx0XHR9LFxuXHRcdHVwZGF0ZUNlbnRlclNjcm9sbCh2YWx1ZSkge1xuXHRcdFx0Y2VudGVyU2Nyb2xsLnNldFZhbHVlKHZhbHVlID8gMSA6IDApO1xuXHRcdH0sXG5cdFx0dXBkYXRlTWF4U2Nyb2xsKHZhbHVlKSB7XG5cdFx0XHRpZih2YWx1ZSAhPSBudWxsKXtcblx0XHRcdFx0aGFzTWF4U2Nyb2xsWC5zZXRWYWx1ZSgxKTtcblx0XHRcdFx0bWF4U2Nyb2xsWC5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aGFzTWF4U2Nyb2xsWC5zZXRWYWx1ZSgwKTtcblx0XHRcdFx0bWF4U2Nyb2xsWC5zZXRWYWx1ZSgwKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNjcm9sbFRvKHZhbHVlLCB3aXRoQW5pbWF0aW9uID0gdHJ1ZSkge1xuXHRcdFx0c2Nyb2xsVG9WYWx1ZS5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHRzY3JvbGxUb1dpdGhBbmltYXRpb24uc2V0VmFsdWUod2l0aEFuaW1hdGlvbiA/IDEgOiAwKTtcblx0XHRcdGxvZ2ljU3RhdGUuc2V0VmFsdWUoTG9naWNTdGF0ZS5TQ1JPTExfVE8pO1xuXHRcdH0sXG5cdH0pO1xuXG5cdHJldHVybiByZXN1bHQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBR0EsU0FBUUEsS0FBUixRQUFvQiw4QkFBcEI7QUFDQSxPQUFPQyxZQUFQLE1BQXlCLFFBQXpCO0FBQ0EsU0FBUUMsV0FBUixFQUFxQkMsWUFBckIsUUFBd0MscUJBQXhDO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQix5QkFBckI7QUFDQSxNQUFNO0VBQUNDLElBQUQ7RUFBT0MsU0FBUDtFQUFrQkMsVUFBbEI7RUFBOEJDLElBQTlCO0VBQW9DQyxLQUFwQztFQUEyQ0MsR0FBM0M7RUFBZ0RDO0FBQWhELElBQXlEUCxRQUEvRDtBQUVBLE1BQU1RLFVBQVUsR0FBRztFQUNsQkMsSUFBSSxFQUFFLENBRFk7RUFFbEJDLEtBQUssRUFBRSxDQUZXO0VBR2xCQyxNQUFNLEVBQUUsQ0FIVTtFQUlsQkMsT0FBTyxFQUFFLENBSlM7RUFLbEJDLFNBQVMsRUFBRTtBQUxP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