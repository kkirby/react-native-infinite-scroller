function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @ts-nocheck
import { State } from 'react-native-gesture-handler';
import EventEmitter from 'events';
import { decayHelper, springHelper } from './ReanimatedHelpers';
import Animated from 'react-native-reanimated';
const {
  call,
  stopClock,
  startClock,
  diff,
  debug,
  abs,
  round
} = Animated;
const LogicState = {
  IDLE: 0,
  DECAY: 1,
  SPRING: 2,
  GESTURE: 3,
  SCROLL_TO: 4
};

function getOr(value, defaultValue) {
  if (value != null) {
    return value;
  } else {
    return defaultValue;
  }
}

export default function AnimationLogic(options = {}) {
  const {
    springConfig,
    decayConfig
  } = options;
  const eventEmitter = new EventEmitter();
  /**
   * This is used to determine velocity. The clock is started and stopped,
   * and the time in between start and stops is used to calculate velocity.
   **/

  let baseClock = new Animated.Clock();
  /**
   * Stores the current state of our primary logic
   **/

  let logicState = new Animated.Value(LogicState.IDLE);
  let previousLogicState = new Animated.Value(LogicState.IDLE);
  let x = new Animated.Value(getOr(options.startingPosition, 0));
  let velocity = new Animated.Value(0);
  let itemWidth = new Animated.Value(getOr(options.itemWidth, 0));
  let wrapperWidth = new Animated.Value(getOr(options.wrapperWidth, 0));
  /**
   * Holds the center offset
   **/

  let center = Animated.divide(Animated.add(wrapperWidth, itemWidth), 2);
  let centerScroll = new Animated.Value(getOr(options.centerScroll, false) ? 1 : 0);
  /**
   * Holds the value of X + the center offset (if centerScroll is 1).
   **/

  let xWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(x, center), itemWidth)], [x])]);
  let maxScrollX = new Animated.Value(getOr(options.maxScroll, 0));
  let hasMaxScrollX = new Animated.Value(getOr(options.hasMaxScroll, 0));
  /**
   * Holds the destination scroll value when `scrollTo` is called.
   **/

  let scrollToValue = new Animated.Value(0);
  /**
   * Holds wether or not the scroll to should be animated.
   **/

  let scrollToWithAnimation = new Animated.Value(0);
  /**
   *
   **/

  let springToNextItemInDirection = new Animated.Value(0);
  /**
   * Handler for when the x value changes.
   **/

  const onXChange = value => {
    eventEmitter.emit('change', value[0]);
  };
  /**
   * Handler for when the scroll ends.
   **/


  const onScrollEnd = ([scrollEndXWithCenter, scrollEndX]) => {
    eventEmitter.emit('scrollEnd', {
      xWithCenter: scrollEndXWithCenter,
      x: scrollEndX
    });
  };
  /**
   * Handler for when the scroll has settled and no more animations are playing.
   **/


  const onScrollSettled = value => {
    eventEmitter.emit('scrollSettled', value[0]);
  };
  /**
   * Handles spring related stuff.
   **/


  const springState = (() => {
    let snapPoint = new Animated.Value(0);
    let snapPointWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(snapPoint, center), itemWidth)], [snapPoint])]);
    const helper = springHelper(x, snapPoint, velocity, springConfig);
    return _objectSpread(_objectSpread({}, helper), {}, {
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(snapPoint, Animated.multiply(round(Animated.divide([Animated.cond(Animated.eq(logicState, LogicState.SPRING), [Animated.cond(Animated.neq(springToNextItemInDirection, 0), [Animated.add(x, Animated.multiply(itemWidth, springToNextItemInDirection))], [x])], [scrollToValue])], itemWidth)), itemWidth)), Animated.cond(Animated.eq(hasMaxScrollX, 1), [Animated.cond(Animated.greaterThan(snapPoint, 0), [Animated.set(snapPoint, 0)], Animated.cond(Animated.lessThan(snapPoint, maxScrollX), [Animated.set(snapPoint, maxScrollX)]))]), call([snapPointWithCenter, snapPoint], onScrollEnd)]), helper.tick]),
      stop: helper.stop
    });
  })();
  /**
   * Defines if we should spring or decay based on maxScrollX.
   **/


  const shouldSpringInsteadOfDecay = Animated.block([Animated.cond(Animated.eq(hasMaxScrollX, 0), [0], Animated.cond(Animated.greaterThan(x, 0), [1], Animated.cond(Animated.lessThan(x, maxScrollX), [1], [0])))]);
  /**
   * Handles decay related stuff.
   **/

  const decayState = (() => {
    const helper = decayHelper(x, velocity, decayConfig && decayConfig.deceleration ? decayConfig.deceleration : 0.997);
    /**
     * Defines if the decay ended up going past our min/max x (if set)
     **/

    let overshot = new Animated.Value(0);
    return _objectSpread(_objectSpread({}, helper), {}, {
      overshot,
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(overshot, 0), helper.tick], [Animated.cond(Animated.and(Animated.eq(hasMaxScrollX, 1), Animated.or(Animated.greaterThan(x, 0), Animated.lessThan(x, maxScrollX))), [Animated.set(overshot, 1), Animated.set(velocity, helper.velocity), helper.stop], [helper.tick])])])
    });
  })();
  /**
   * Handles everything related to gestures
   **/


  const gestureState = (() => {
    let newX = new Animated.Value(0);
    let pointX = new Animated.Value(0);
    let distX = new Animated.Value(0);
    let deltaX = new Animated.Value(0);
    let startTime = new Animated.Value(0);
    let endTime = new Animated.Value(0);
    let data = {
      x: new Animated.Value(0),
      state: new Animated.Value(-1),
      velocityX: new Animated.Value(0)
    };
    /**
     * Handler for when the gesture starts.
     **/

    let start = Animated.block([startClock(baseClock), Animated.set(logicState, LogicState.GESTURE), Animated.set(distX, 0), Animated.set(startTime, baseClock), Animated.set(pointX, data.x)]);
    /**
     * Handler for gesture move.
     **/

    let move = Animated.block([Animated.set(deltaX, Animated.sub(data.x, pointX)), Animated.set(pointX, data.x), Animated.set(distX, Animated.add(distX, deltaX)), Animated.set(newX, Animated.add(x, deltaX)), Animated.cond(Animated.eq(hasMaxScrollX, 1), [Animated.cond(Animated.or(Animated.greaterThan(newX, 0), Animated.lessThan(newX, maxScrollX)), [Animated.set(newX, Animated.add(x, Animated.divide(deltaX, 3)))])]), Animated.set(x, newX)]);
    /**
     * Handler for gesture end
     **/

    let end = Animated.block([stopClock(baseClock), Animated.set(endTime, baseClock), Animated.set(velocity, data.velocityX), Animated.cond(Animated.or(Animated.eq(shouldSpringInsteadOfDecay, 1), Animated.lessThan(abs(velocity), 3000)), [Animated.cond(Animated.greaterThan(abs(velocity), 0), [Animated.set(springToNextItemInDirection, Animated.divide(abs(velocity), velocity))], [Animated.set(springToNextItemInDirection, 0)]), Animated.set(logicState, LogicState.SPRING), springState.tick], [Animated.set(springToNextItemInDirection, 0), Animated.set(logicState, LogicState.DECAY), decayState.tick])]);
    return {
      data,
      start,
      move,
      end
    };
  })();
  /**
   * Primary logic to determine the value of `x`.
   **/


  const calculatedTransX = Animated.block([Animated.cond(Animated.eq(logicState, LogicState.IDLE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.start])], Animated.cond(Animated.eq(logicState, LogicState.GESTURE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.move], Animated.cond(Animated.eq(gestureState.data.state, State.END), [gestureState.end]))], [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [decayState.stop, springState.stop, gestureState.start], Animated.cond(Animated.eq(logicState, LogicState.DECAY), [springState.stop, decayState.tick, Animated.cond(Animated.eq(decayState.finished, 1), [Animated.cond(Animated.eq(decayState.overshot, 0), [Animated.set(velocity, 0)]), Animated.set(logicState, LogicState.SPRING), springState.tick])], Animated.cond(Animated.eq(logicState, LogicState.SPRING), [decayState.stop, springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])], Animated.cond(Animated.eq(logicState, LogicState.SCROLL_TO), [Animated.cond(Animated.eq(scrollToWithAnimation, 0), [decayState.stop, springState.stop, Animated.set(x, scrollToValue), Animated.set(logicState, LogicState.IDLE), call([xWithCenter, x], onScrollEnd)], [Animated.set(velocity, 0), Animated.cond(Animated.or(Animated.neq(diff(scrollToValue), 0), Animated.neq(previousLogicState, logicState)), [decayState.stop, springState.stop]), springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])])]))))])), Animated.cond(Animated.and(Animated.neq(diff(logicState), 0), Animated.eq(logicState, LogicState.IDLE)), [call([xWithCenter, logicState], onScrollSettled)]), call([xWithCenter], onXChange), Animated.set(previousLogicState, logicState), xWithCenter]);
  const gestureHandler = Animated.event([{
    nativeEvent: gestureState.data
  }]);
  const result = Object.create(eventEmitter);
  Object.assign(result, {
    x: calculatedTransX,
    gestureHandler,

    updateItemWidth(value) {
      itemWidth.setValue(value);
    },

    updateWrapperWidth(value) {
      wrapperWidth.setValue(value);
    },

    updateCenterScroll(value) {
      centerScroll.setValue(value ? 1 : 0);
    },

    updateMaxScroll(value) {
      if (value != null) {
        hasMaxScrollX.setValue(1);
        maxScrollX.setValue(value);
      } else {
        hasMaxScrollX.setValue(0);
        maxScrollX.setValue(0);
      }
    },

    scrollTo(value, withAnimation = true) {
      scrollToValue.setValue(value);
      scrollToWithAnimation.setValue(withAnimation ? 1 : 0);
      logicState.setValue(LogicState.SCROLL_TO);
    }

  });
  return result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9BbmltYXRpb25Mb2dpYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJTdGF0ZSIsIkV2ZW50RW1pdHRlciIsImRlY2F5SGVscGVyIiwic3ByaW5nSGVscGVyIiwiQW5pbWF0ZWQiLCJjYWxsIiwic3RvcENsb2NrIiwic3RhcnRDbG9jayIsImRpZmYiLCJkZWJ1ZyIsImFicyIsInJvdW5kIiwiTG9naWNTdGF0ZSIsIklETEUiLCJERUNBWSIsIlNQUklORyIsIkdFU1RVUkUiLCJTQ1JPTExfVE8iLCJnZXRPciIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiQW5pbWF0aW9uTG9naWMiLCJvcHRpb25zIiwic3ByaW5nQ29uZmlnIiwiZGVjYXlDb25maWciLCJldmVudEVtaXR0ZXIiLCJiYXNlQ2xvY2siLCJDbG9jayIsImxvZ2ljU3RhdGUiLCJWYWx1ZSIsInByZXZpb3VzTG9naWNTdGF0ZSIsIngiLCJzdGFydGluZ1Bvc2l0aW9uIiwidmVsb2NpdHkiLCJpdGVtV2lkdGgiLCJ3cmFwcGVyV2lkdGgiLCJjZW50ZXIiLCJjZW50ZXJTY3JvbGwiLCJ4V2l0aENlbnRlciIsIm1heFNjcm9sbFgiLCJtYXhTY3JvbGwiLCJoYXNNYXhTY3JvbGxYIiwiaGFzTWF4U2Nyb2xsIiwic2Nyb2xsVG9WYWx1ZSIsInNjcm9sbFRvV2l0aEFuaW1hdGlvbiIsInNwcmluZ1RvTmV4dEl0ZW1JbkRpcmVjdGlvbiIsIm9uWENoYW5nZSIsImVtaXQiLCJvblNjcm9sbEVuZCIsInNjcm9sbEVuZFhXaXRoQ2VudGVyIiwic2Nyb2xsRW5kWCIsIm9uU2Nyb2xsU2V0dGxlZCIsInNwcmluZ1N0YXRlIiwic25hcFBvaW50Iiwic25hcFBvaW50V2l0aENlbnRlciIsImhlbHBlciIsInRpY2siLCJydW5uaW5nIiwic3RvcCIsInNob3VsZFNwcmluZ0luc3RlYWRPZkRlY2F5IiwiZGVjYXlTdGF0ZSIsImRlY2VsZXJhdGlvbiIsIm92ZXJzaG90IiwiZ2VzdHVyZVN0YXRlIiwibmV3WCIsInBvaW50WCIsImRpc3RYIiwiZGVsdGFYIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImRhdGEiLCJzdGF0ZSIsInZlbG9jaXR5WCIsInN0YXJ0IiwibW92ZSIsImVuZCIsImNhbGN1bGF0ZWRUcmFuc1giLCJBQ1RJVkUiLCJFTkQiLCJmaW5pc2hlZCIsImdlc3R1cmVIYW5kbGVyIiwiZXZlbnQiLCJuYXRpdmVFdmVudCIsInJlc3VsdCIsIk9iamVjdCIsImNyZWF0ZSIsImFzc2lnbiIsInVwZGF0ZUl0ZW1XaWR0aCIsInNldFZhbHVlIiwidXBkYXRlV3JhcHBlcldpZHRoIiwidXBkYXRlQ2VudGVyU2Nyb2xsIiwidXBkYXRlTWF4U2Nyb2xsIiwic2Nyb2xsVG8iLCJ3aXRoQW5pbWF0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUdBLFNBQVFBLEtBQVIsUUFBb0IsOEJBQXBCO0FBQ0EsT0FBT0MsWUFBUCxNQUF5QixRQUF6QjtBQUNBLFNBQVFDLFdBQVIsRUFBcUJDLFlBQXJCLFFBQXdDLHFCQUF4QztBQUNBLE9BQU9DLFFBQVAsTUFBcUIseUJBQXJCO0FBQ0EsTUFBTTtBQUFDQyxFQUFBQSxJQUFEO0FBQU9DLEVBQUFBLFNBQVA7QUFBa0JDLEVBQUFBLFVBQWxCO0FBQThCQyxFQUFBQSxJQUE5QjtBQUFvQ0MsRUFBQUEsS0FBcEM7QUFBMkNDLEVBQUFBLEdBQTNDO0FBQWdEQyxFQUFBQTtBQUFoRCxJQUF5RFAsUUFBL0Q7QUFFQSxNQUFNUSxVQUFVLEdBQUc7QUFDbEJDLEVBQUFBLElBQUksRUFBRSxDQURZO0FBRWxCQyxFQUFBQSxLQUFLLEVBQUUsQ0FGVztBQUdsQkMsRUFBQUEsTUFBTSxFQUFFLENBSFU7QUFJbEJDLEVBQUFBLE9BQU8sRUFBRSxDQUpTO0FBS2xCQyxFQUFBQSxTQUFTLEVBQUU7QUFMTyxDQUFuQjs7QUFRQSxTQUFTQyxLQUFULENBQWVDLEtBQWYsRUFBc0JDLFlBQXRCLEVBQW9DO0FBQ25DLE1BQUlELEtBQUssSUFBSSxJQUFiLEVBQW1CO0FBQ2xCLFdBQU9BLEtBQVA7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TUFBQUEsVUFBVSxDQUFDNEQsUUFBWCxDQUFvQjVFLFVBQVUsQ0FBQ0ssU0FBL0I7QUFDQTs7QUExQm9CLEdBQXRCO0FBNkJBLFNBQU9rRSxNQUFQO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuXG5pbXBvcnQgcmUgZnJvbSAnQGtraXJiYXRza2kvanMtdG8tcmVhbmltYXRlZC5tYWNybyc7XG5pbXBvcnQge1N0YXRlfSBmcm9tICdyZWFjdC1uYXRpdmUtZ2VzdHVyZS1oYW5kbGVyJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7ZGVjYXlIZWxwZXIsIHNwcmluZ0hlbHBlcn0gZnJvbSAnLi9SZWFuaW1hdGVkSGVscGVycyc7XG5pbXBvcnQgQW5pbWF0ZWQgZnJvbSAncmVhY3QtbmF0aXZlLXJlYW5pbWF0ZWQnO1xuY29uc3Qge2NhbGwsIHN0b3BDbG9jaywgc3RhcnRDbG9jaywgZGlmZiwgZGVidWcsIGFicywgcm91bmR9ID0gQW5pbWF0ZWQ7XG5cbmNvbnN0IExvZ2ljU3RhdGUgPSB7XG5cdElETEU6IDAsXG5cdERFQ0FZOiAxLFxuXHRTUFJJTkc6IDIsXG5cdEdFU1RVUkU6IDMsXG5cdFNDUk9MTF9UTzogNCxcbn07XG5cbmZ1bmN0aW9uIGdldE9yKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblx0aWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbmltYXRpb25Mb2dpYyhvcHRpb25zID0ge30pIHtcblx0Y29uc3Qge3NwcmluZ0NvbmZpZywgZGVjYXlDb25maWd9ID0gb3B0aW9ucztcblx0Y29uc3QgZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHQvKipcblx0ICogVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB2ZWxvY2l0eS4gVGhlIGNsb2NrIGlzIHN0YXJ0ZWQgYW5kIHN0b3BwZWQsXG5cdCAqIGFuZCB0aGUgdGltZSBpbiBiZXR3ZWVuIHN0YXJ0IGFuZCBzdG9wcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB2ZWxvY2l0eS5cblx0ICoqL1xuXHRsZXQgYmFzZUNsb2NrID0gbmV3IEFuaW1hdGVkLkNsb2NrKCk7XG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2Ygb3VyIHByaW1hcnkgbG9naWNcblx0ICoqL1xuXHRsZXQgbG9naWNTdGF0ZSA9IG5ldyBBbmltYXRlZC5WYWx1ZShMb2dpY1N0YXRlLklETEUpO1xuXHRsZXQgcHJldmlvdXNMb2dpY1N0YXRlID0gbmV3IEFuaW1hdGVkLlZhbHVlKExvZ2ljU3RhdGUuSURMRSk7XG5cblx0bGV0IHggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoZ2V0T3Iob3B0aW9ucy5zdGFydGluZ1Bvc2l0aW9uLCAwKSk7XG5cdGxldCB2ZWxvY2l0eSA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHRsZXQgaXRlbVdpZHRoID0gbmV3IEFuaW1hdGVkLlZhbHVlKGdldE9yKG9wdGlvbnMuaXRlbVdpZHRoLCAwKSk7XG5cdGxldCB3cmFwcGVyV2lkdGggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoZ2V0T3Iob3B0aW9ucy53cmFwcGVyV2lkdGgsIDApKTtcblxuXHQvKipcblx0ICogSG9sZHMgdGhlIGNlbnRlciBvZmZzZXRcblx0ICoqL1xuXHRsZXQgY2VudGVyID0gcmUoKHdyYXBwZXJXaWR0aCArIGl0ZW1XaWR0aCkgLyAyKTtcblx0bGV0IGNlbnRlclNjcm9sbCA9IG5ldyBBbmltYXRlZC5WYWx1ZShcblx0XHRnZXRPcihvcHRpb25zLmNlbnRlclNjcm9sbCwgZmFsc2UpID8gMSA6IDAsXG5cdCk7XG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgdmFsdWUgb2YgWCArIHRoZSBjZW50ZXIgb2Zmc2V0IChpZiBjZW50ZXJTY3JvbGwgaXMgMSkuXG5cdCAqKi9cblx0bGV0IHhXaXRoQ2VudGVyID0gcmUoKCkgPT4ge1xuXHRcdGlmIChjZW50ZXJTY3JvbGwgPT09IDEpIHtcblx0XHRcdHggKyBjZW50ZXIgLSBpdGVtV2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHg7XG5cdFx0fVxuXHR9KTtcblxuXHRsZXQgbWF4U2Nyb2xsWCA9IG5ldyBBbmltYXRlZC5WYWx1ZShnZXRPcihvcHRpb25zLm1heFNjcm9sbCwgMCkpO1xuXHRsZXQgaGFzTWF4U2Nyb2xsWCA9IG5ldyBBbmltYXRlZC5WYWx1ZShnZXRPcihvcHRpb25zLmhhc01heFNjcm9sbCwgMCkpO1xuXG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgZGVzdGluYXRpb24gc2Nyb2xsIHZhbHVlIHdoZW4gYHNjcm9sbFRvYCBpcyBjYWxsZWQuXG5cdCAqKi9cblx0bGV0IHNjcm9sbFRvVmFsdWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0LyoqXG5cdCAqIEhvbGRzIHdldGhlciBvciBub3QgdGhlIHNjcm9sbCB0byBzaG91bGQgYmUgYW5pbWF0ZWQuXG5cdCAqKi9cblx0bGV0IHNjcm9sbFRvV2l0aEFuaW1hdGlvbiA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHQvKipcblx0ICpcblx0ICoqL1xuXHRsZXQgc3ByaW5nVG9OZXh0SXRlbUluRGlyZWN0aW9uID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSB4IHZhbHVlIGNoYW5nZXMuXG5cdCAqKi9cblx0Y29uc3Qgb25YQ2hhbmdlID0gdmFsdWUgPT4ge1xuXHRcdGV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB2YWx1ZVswXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIHNjcm9sbCBlbmRzLlxuXHQgKiovXG5cdGNvbnN0IG9uU2Nyb2xsRW5kID0gKFtzY3JvbGxFbmRYV2l0aENlbnRlciwgc2Nyb2xsRW5kWF0pID0+IHtcblx0XHRldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsRW5kJywge1xuXHRcdFx0eFdpdGhDZW50ZXI6IHNjcm9sbEVuZFhXaXRoQ2VudGVyLFxuXHRcdFx0eDogc2Nyb2xsRW5kWCxcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlciBmb3Igd2hlbiB0aGUgc2Nyb2xsIGhhcyBzZXR0bGVkIGFuZCBubyBtb3JlIGFuaW1hdGlvbnMgYXJlIHBsYXlpbmcuXG5cdCAqKi9cblx0Y29uc3Qgb25TY3JvbGxTZXR0bGVkID0gdmFsdWUgPT4ge1xuXHRcdGV2ZW50RW1pdHRlci5lbWl0KCdzY3JvbGxTZXR0bGVkJywgdmFsdWVbMF0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHNwcmluZyByZWxhdGVkIHN0dWZmLlxuXHQgKiovXG5cdGNvbnN0IHNwcmluZ1N0YXRlID0gKCgpID0+IHtcblx0XHRsZXQgc25hcFBvaW50ID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdFx0bGV0IHNuYXBQb2ludFdpdGhDZW50ZXIgPSByZSgoKSA9PiB7XG5cdFx0XHRpZiAoY2VudGVyU2Nyb2xsID09PSAxKSB7XG5cdFx0XHRcdHNuYXBQb2ludCArIGNlbnRlciAtIGl0ZW1XaWR0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNuYXBQb2ludDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGNvbnN0IGhlbHBlciA9IHNwcmluZ0hlbHBlcih4LCBzbmFwUG9pbnQsIHZlbG9jaXR5LCBzcHJpbmdDb25maWcpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdC4uLmhlbHBlcixcblx0XHRcdHRpY2s6IHJlKCgpID0+IHtcblx0XHRcdFx0aWYgKGhlbHBlci5ydW5uaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0c25hcFBvaW50ID1cblx0XHRcdFx0XHRcdHJvdW5kKFxuXHRcdFx0XHRcdFx0XHQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLlNQUklORykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHNwcmluZ1RvTmV4dEl0ZW1JbkRpcmVjdGlvbiAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4ICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpdGVtV2lkdGggKlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3ByaW5nVG9OZXh0SXRlbUluRGlyZWN0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0eDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2Nyb2xsVG9WYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pIC8gaXRlbVdpZHRoLFxuXHRcdFx0XHRcdFx0KSAqIGl0ZW1XaWR0aDtcblx0XHRcdFx0XHRpZiAoaGFzTWF4U2Nyb2xsWCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKHNuYXBQb2ludCA+IDApIHtcblx0XHRcdFx0XHRcdFx0c25hcFBvaW50ID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc25hcFBvaW50IDwgbWF4U2Nyb2xsWCkge1xuXHRcdFx0XHRcdFx0XHRzbmFwUG9pbnQgPSBtYXhTY3JvbGxYO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxsKFtzbmFwUG9pbnRXaXRoQ2VudGVyLCBzbmFwUG9pbnRdLCBvblNjcm9sbEVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGVscGVyLnRpY2s7XG5cdFx0XHR9KSxcblx0XHRcdHN0b3A6IGhlbHBlci5zdG9wLFxuXHRcdH07XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgaWYgd2Ugc2hvdWxkIHNwcmluZyBvciBkZWNheSBiYXNlZCBvbiBtYXhTY3JvbGxYLlxuXHQgKiovXG5cdGNvbnN0IHNob3VsZFNwcmluZ0luc3RlYWRPZkRlY2F5ID0gcmUoKCkgPT4ge1xuXHRcdGlmIChoYXNNYXhTY3JvbGxYID09PSAwKSB7XG5cdFx0XHQwO1xuXHRcdH0gZWxzZSBpZiAoeCA+IDApIHtcblx0XHRcdDE7XG5cdFx0fSBlbHNlIGlmICh4IDwgbWF4U2Nyb2xsWCkge1xuXHRcdFx0MTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0MDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGRlY2F5IHJlbGF0ZWQgc3R1ZmYuXG5cdCAqKi9cblx0Y29uc3QgZGVjYXlTdGF0ZSA9ICgoKSA9PiB7XG5cdFx0Y29uc3QgaGVscGVyID0gZGVjYXlIZWxwZXIoXG5cdFx0XHR4LFxuXHRcdFx0dmVsb2NpdHksXG5cdFx0XHRkZWNheUNvbmZpZyAmJiBkZWNheUNvbmZpZy5kZWNlbGVyYXRpb25cblx0XHRcdFx0PyBkZWNheUNvbmZpZy5kZWNlbGVyYXRpb25cblx0XHRcdFx0OiAwLjk5Nyxcblx0XHQpO1xuXHRcdC8qKlxuXHRcdCAqIERlZmluZXMgaWYgdGhlIGRlY2F5IGVuZGVkIHVwIGdvaW5nIHBhc3Qgb3VyIG1pbi9tYXggeCAoaWYgc2V0KVxuXHRcdCAqKi9cblx0XHRsZXQgb3ZlcnNob3QgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdC4uLmhlbHBlcixcblx0XHRcdG92ZXJzaG90LFxuXHRcdFx0dGljazogcmUoKCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSdyZSBub3QgcnVubmluZyAscmVzZXQgc3R1ZmYuXG5cdFx0XHRcdGlmIChoZWxwZXIucnVubmluZyA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIFJlc2V0IG92ZXJzaG90IHRvIDBcblx0XHRcdFx0XHRvdmVyc2hvdCA9IDA7XG5cdFx0XHRcdFx0aGVscGVyLnRpY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGhhc01heFNjcm9sbFggPT09IDEgJiYgKHggPiAwIHx8IHggPCBtYXhTY3JvbGxYKSkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIG1heFNjcm9sbCBzZXQgYW5kIHdlIHdlbnQgcGFzc2VkIGl0LCBzZXQgb3ZlcnNob3QgdG8gMS5cblx0XHRcdFx0XHRcdG92ZXJzaG90ID0gMTtcblx0XHRcdFx0XHRcdC8vIFNldCBvdXIgdmVsb2NpdHkgdG8gdGhlIGRlY2F5J3MuXG5cdFx0XHRcdFx0XHR2ZWxvY2l0eSA9IGhlbHBlci52ZWxvY2l0eTtcblx0XHRcdFx0XHRcdGhlbHBlci5zdG9wO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRoZWxwZXIudGljaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdH07XG5cdH0pKCk7XG5cdC8qKlxuXHQgKiBIYW5kbGVzIGV2ZXJ5dGhpbmcgcmVsYXRlZCB0byBnZXN0dXJlc1xuXHQgKiovXG5cdGNvbnN0IGdlc3R1cmVTdGF0ZSA9ICgoKSA9PiB7XG5cdFx0bGV0IG5ld1ggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IHBvaW50WCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgZGlzdFggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IGRlbHRhWCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgc3RhcnRUaW1lID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBlbmRUaW1lID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdFx0bGV0IGRhdGEgPSB7XG5cdFx0XHR4OiBuZXcgQW5pbWF0ZWQuVmFsdWUoMCksXG5cdFx0XHRzdGF0ZTogbmV3IEFuaW1hdGVkLlZhbHVlKC0xKSxcblx0XHRcdHZlbG9jaXR5WDogbmV3IEFuaW1hdGVkLlZhbHVlKDApLFxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSBnZXN0dXJlIHN0YXJ0cy5cblx0XHQgKiovXG5cdFx0bGV0IHN0YXJ0ID0gcmUoKCkgPT4ge1xuXHRcdFx0c3RhcnRDbG9jayhiYXNlQ2xvY2spO1xuXHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuR0VTVFVSRTtcblx0XHRcdGRpc3RYID0gMDtcblx0XHRcdHN0YXJ0VGltZSA9IGJhc2VDbG9jaztcblx0XHRcdHBvaW50WCA9IGRhdGEueDtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGdlc3R1cmUgbW92ZS5cblx0XHQgKiovXG5cdFx0bGV0IG1vdmUgPSByZSgoKSA9PiB7XG5cdFx0XHRkZWx0YVggPSBkYXRhLnggLSBwb2ludFg7XG5cblx0XHRcdHBvaW50WCA9IGRhdGEueDtcblx0XHRcdGRpc3RYID0gZGlzdFggKyBkZWx0YVg7XG5cdFx0XHRuZXdYID0geCArIGRlbHRhWDtcblx0XHRcdC8vIFRoaXMgd2lsbCBnaXZlIGFuIGVsYXN0aWMgZmVlbCB3aGVuIG92ZXItc2Nyb2xsaW5nLCBhZGRpbmcgcmVzaXN0YW5jZSB0byB0aGUgcHVsbC5cblx0XHRcdGlmIChoYXNNYXhTY3JvbGxYID09PSAxKSB7XG5cdFx0XHRcdGlmIChuZXdYID4gMCB8fCBuZXdYIDwgbWF4U2Nyb2xsWCkge1xuXHRcdFx0XHRcdG5ld1ggPSB4ICsgZGVsdGFYIC8gMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0eCA9IG5ld1g7XG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciBnZXN0dXJlIGVuZFxuXHRcdCAqKi9cblx0XHRsZXQgZW5kID0gcmUoKCkgPT4ge1xuXHRcdFx0c3RvcENsb2NrKGJhc2VDbG9jayk7XG5cdFx0XHRlbmRUaW1lID0gYmFzZUNsb2NrO1xuXHRcdFx0dmVsb2NpdHkgPSBkYXRhLnZlbG9jaXR5WDtcblx0XHRcdGlmIChzaG91bGRTcHJpbmdJbnN0ZWFkT2ZEZWNheSA9PT0gMSB8fCBhYnModmVsb2NpdHkpIDwgMzAwMCkge1xuXHRcdFx0XHRpZiAoYWJzKHZlbG9jaXR5KSA+IDApIHtcblx0XHRcdFx0XHRzcHJpbmdUb05leHRJdGVtSW5EaXJlY3Rpb24gPSBhYnModmVsb2NpdHkpIC8gdmVsb2NpdHk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3ByaW5nVG9OZXh0SXRlbUluRGlyZWN0aW9uID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5TUFJJTkc7XG5cdFx0XHRcdHNwcmluZ1N0YXRlLnRpY2s7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzcHJpbmdUb05leHRJdGVtSW5EaXJlY3Rpb24gPSAwO1xuXHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5ERUNBWTtcblx0XHRcdFx0ZGVjYXlTdGF0ZS50aWNrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHtkYXRhLCBzdGFydCwgbW92ZSwgZW5kfTtcblx0fSkoKTtcblxuXHQvKipcblx0ICogUHJpbWFyeSBsb2dpYyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB4YC5cblx0ICoqL1xuXHRjb25zdCBjYWxjdWxhdGVkVHJhbnNYID0gcmUoKCkgPT4ge1xuXHRcdGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLklETEUpIHtcblx0XHRcdC8vIFdlJ3ZlIHN0YXJ0ZWQgc2Nyb2xsaW5nXG5cdFx0XHRpZiAoZ2VzdHVyZVN0YXRlLmRhdGEuc3RhdGUgPT09IFN0YXRlLkFDVElWRSkge1xuXHRcdFx0XHRnZXN0dXJlU3RhdGUuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLkdFU1RVUkUpIHtcblx0XHRcdC8vIFdlJ3JlIHN0aWxsIHNjcm9sbGluZ1xuXHRcdFx0aWYgKGdlc3R1cmVTdGF0ZS5kYXRhLnN0YXRlID09PSBTdGF0ZS5BQ1RJVkUpIHtcblx0XHRcdFx0Z2VzdHVyZVN0YXRlLm1vdmU7XG5cdFx0XHR9XG5cdFx0XHQvLyBTY3JvbGxpbmcgaGFzIGVuZGVkXG5cdFx0XHRlbHNlIGlmIChnZXN0dXJlU3RhdGUuZGF0YS5zdGF0ZSA9PT0gU3RhdGUuRU5EKSB7XG5cdFx0XHRcdGdlc3R1cmVTdGF0ZS5lbmQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIFdlJ3JlIG5vdCBpZGxlIGFuZCBzY3JvbGxpbmcgaXNuJ3QgYWN0aXZlXG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBXZSd2ZSBzdGFydGVkIHNjcm9sbGluZyBhZ2FpblxuXHRcdFx0aWYgKGdlc3R1cmVTdGF0ZS5kYXRhLnN0YXRlID09PSBTdGF0ZS5BQ1RJVkUpIHtcblx0XHRcdFx0ZGVjYXlTdGF0ZS5zdG9wO1xuXHRcdFx0XHRzcHJpbmdTdGF0ZS5zdG9wO1xuXHRcdFx0XHRnZXN0dXJlU3RhdGUuc3RhcnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSdyZSBpbiB0aGUgZGVjYXkgc3RhdGVcblx0XHRcdGVsc2UgaWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuREVDQVkpIHtcblx0XHRcdFx0c3ByaW5nU3RhdGUuc3RvcDtcblx0XHRcdFx0ZGVjYXlTdGF0ZS50aWNrO1xuXHRcdFx0XHRpZiAoZGVjYXlTdGF0ZS5maW5pc2hlZCA9PT0gMSkge1xuXHRcdFx0XHRcdGlmIChkZWNheVN0YXRlLm92ZXJzaG90ID09PSAwKSB7XG5cdFx0XHRcdFx0XHR2ZWxvY2l0eSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLlNQUklORztcblx0XHRcdFx0XHRzcHJpbmdTdGF0ZS50aWNrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSdyZSBpbiB0aGUgc3ByaW5nIHN0YXRlXG5cdFx0XHRlbHNlIGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLlNQUklORykge1xuXHRcdFx0XHRkZWNheVN0YXRlLnN0b3A7XG5cdFx0XHRcdHNwcmluZ1N0YXRlLnRpY2s7XG5cdFx0XHRcdGlmIChzcHJpbmdTdGF0ZS5maW5pc2hlZCA9PT0gMSkge1xuXHRcdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLklETEU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFdlJ3JlIGluIHRoZSBzY3JvbGwgdG8gc3RhdGVcblx0XHRcdGVsc2UgaWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuU0NST0xMX1RPKSB7XG5cdFx0XHRcdGlmIChzY3JvbGxUb1dpdGhBbmltYXRpb24gPT09IDApIHtcblx0XHRcdFx0XHRkZWNheVN0YXRlLnN0b3A7XG5cdFx0XHRcdFx0c3ByaW5nU3RhdGUuc3RvcDtcblx0XHRcdFx0XHR4ID0gc2Nyb2xsVG9WYWx1ZTtcblx0XHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5JRExFO1xuXHRcdFx0XHRcdGNhbGwoW3hXaXRoQ2VudGVyLCB4XSwgb25TY3JvbGxFbmQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFNldCB2ZWxvY2l0eSB0byAwIHNpbmNlIHdlJ3JlIG5vdCBzY3JvbGxpbmdcblx0XHRcdFx0XHR2ZWxvY2l0eSA9IDA7XG5cdFx0XHRcdFx0Ly8gVGhpcyBjaGVja3MgaWYgdGhlIHNjcm9sbFRvVmFsdWUgY2hhbmdlZCwgb3IgaWYgdGhlIHN0YXRlIGNoYW5nZWQgZnJvbSBzcHJpbmcgdG8gc2Nyb2xsLlxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGRpZmYoc2Nyb2xsVG9WYWx1ZSkgIT09IDAgfHxcblx0XHRcdFx0XHRcdHByZXZpb3VzTG9naWNTdGF0ZSAhPT0gbG9naWNTdGF0ZVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Ly8gU3RvcCBldmVyeXRoaW5nLCByZXNldHRpbmcgaXRcblx0XHRcdFx0XHRcdGRlY2F5U3RhdGUuc3RvcDtcblx0XHRcdFx0XHRcdHNwcmluZ1N0YXRlLnN0b3A7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNwcmluZ1N0YXRlLnRpY2s7XG5cdFx0XHRcdFx0aWYgKHNwcmluZ1N0YXRlLmZpbmlzaGVkID09PSAxKSB7XG5cdFx0XHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5JRExFO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBTY3JvbGwgaGFzIHNldHRsZWRcblx0XHRpZiAoZGlmZihsb2dpY1N0YXRlKSAhPT0gMCAmJiBsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLklETEUpIHtcblx0XHRcdGNhbGwoW3hXaXRoQ2VudGVyLCBsb2dpY1N0YXRlXSwgb25TY3JvbGxTZXR0bGVkKTtcblx0XHR9XG5cdFx0Ly8gWCBoYXMgY2hhbmdlZFxuXHRcdGNhbGwoW3hXaXRoQ2VudGVyXSwgb25YQ2hhbmdlKTtcblx0XHRwcmV2aW91c0xvZ2ljU3RhdGUgPSBsb2dpY1N0YXRlO1xuXHRcdHhXaXRoQ2VudGVyO1xuXHR9KTtcblxuXHRjb25zdCBnZXN0dXJlSGFuZGxlciA9IEFuaW1hdGVkLmV2ZW50KFtcblx0XHR7XG5cdFx0XHRuYXRpdmVFdmVudDogZ2VzdHVyZVN0YXRlLmRhdGEsXG5cdFx0fSxcblx0XSk7XG5cblx0Y29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShldmVudEVtaXR0ZXIpO1xuXG5cdE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7XG5cdFx0eDogY2FsY3VsYXRlZFRyYW5zWCxcblx0XHRnZXN0dXJlSGFuZGxlcixcblx0XHR1cGRhdGVJdGVtV2lkdGgodmFsdWUpIHtcblx0XHRcdGl0ZW1XaWR0aC5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0fSxcblx0XHR1cGRhdGVXcmFwcGVyV2lkdGgodmFsdWUpIHtcblx0XHRcdHdyYXBwZXJXaWR0aC5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0fSxcblx0XHR1cGRhdGVDZW50ZXJTY3JvbGwodmFsdWUpIHtcblx0XHRcdGNlbnRlclNjcm9sbC5zZXRWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcblx0XHR9LFxuXHRcdHVwZGF0ZU1heFNjcm9sbCh2YWx1ZSkge1xuXHRcdFx0aWYodmFsdWUgIT0gbnVsbCl7XG5cdFx0XHRcdGhhc01heFNjcm9sbFguc2V0VmFsdWUoMSk7XG5cdFx0XHRcdG1heFNjcm9sbFguc2V0VmFsdWUodmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGhhc01heFNjcm9sbFguc2V0VmFsdWUoMCk7XG5cdFx0XHRcdG1heFNjcm9sbFguc2V0VmFsdWUoMCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzY3JvbGxUbyh2YWx1ZSwgd2l0aEFuaW1hdGlvbiA9IHRydWUpIHtcblx0XHRcdHNjcm9sbFRvVmFsdWUuc2V0VmFsdWUodmFsdWUpO1xuXHRcdFx0c2Nyb2xsVG9XaXRoQW5pbWF0aW9uLnNldFZhbHVlKHdpdGhBbmltYXRpb24gPyAxIDogMCk7XG5cdFx0XHRsb2dpY1N0YXRlLnNldFZhbHVlKExvZ2ljU3RhdGUuU0NST0xMX1RPKTtcblx0XHR9LFxuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuIl19