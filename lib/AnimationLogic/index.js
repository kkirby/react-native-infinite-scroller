function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @ts-nocheck
import { State } from 'react-native-gesture-handler';
import EventEmitter from 'events';
import { decayHelper, springHelper } from './ReanimatedHelpers';
import Animated from 'react-native-reanimated';
const {
  call,
  stopClock,
  startClock,
  diff,
  debug,
  abs,
  round
} = Animated;
const LogicState = {
  IDLE: 0,
  DECAY: 1,
  SPRING: 2,
  GESTURE: 3,
  SCROLL_TO: 4
};

function getOr(value, defaultValue) {
  if (value != null) {
    return value;
  } else {
    return defaultValue;
  }
}

export default function AnimationLogic(options = {}) {
  const {
    springConfig,
    decayConfig
  } = options;
  const eventEmitter = new EventEmitter();
  /**
   * This is used to determine velocity. The clock is started and stopped,
   * and the time in between start and stops is used to calculate velocity.
   **/

  let baseClock = new Animated.Clock();
  /**
   * Stores the current state of our primary logic
   **/

  let logicState = new Animated.Value(LogicState.IDLE);
  let previousLogicState = new Animated.Value(LogicState.IDLE);
  let x = new Animated.Value(getOr(options.startingPosition, 0));
  let velocity = new Animated.Value(0);
  let itemWidth = new Animated.Value(getOr(options.itemWidth, 0));
  let wrapperWidth = new Animated.Value(getOr(options.wrapperWidth, 0));
  /**
   * Holds the center offset
   **/

  let center = Animated.divide(Animated.add(wrapperWidth, itemWidth), 2);
  let centerScroll = new Animated.Value(getOr(options.centerScroll, false) ? 1 : 0);
  /**
   * Holds the value of X + the center offset (if centerScroll is 1).
   **/

  let xWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(x, center), itemWidth)], [x])]);
  let maxScrollX = new Animated.Value(getOr(options.maxScroll, 0));
  /**
   * Holds the destination scroll value when `scrollTo` is called.
   **/

  let scrollToValue = new Animated.Value(0);
  /**
   * Holds wether or not the scroll to should be animated.
   **/

  let scrollToWithAnimation = new Animated.Value(0);
  /**
   *
   **/

  let springToNextItemInDirection = new Animated.Value(0);
  /**
   * Handler for when the x value changes.
   **/

  const onXChange = value => {
    eventEmitter.emit('change', value[0]);
  };
  /**
   * Handler for when the scroll ends.
   **/


  const onScrollEnd = ([scrollEndXWithCenter, scrollEndX]) => {
    eventEmitter.emit('scrollEnd', {
      xWithCenter: scrollEndXWithCenter,
      x: scrollEndX
    });
  };
  /**
   * Handler for when the scroll has settled and no more animations are playing.
   **/


  const onScrollSettled = value => {
    eventEmitter.emit('scrollSettled', value[0]);
  };
  /**
   * Handles spring related stuff.
   **/


  const springState = (() => {
    let snapPoint = new Animated.Value(0);
    let snapPointWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(snapPoint, center), itemWidth)], [snapPoint])]);
    const helper = springHelper(x, snapPoint, velocity, springConfig);
    return _objectSpread({}, helper, {
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(snapPoint, Animated.multiply(round(Animated.divide([Animated.cond(Animated.eq(logicState, LogicState.SPRING), [Animated.cond(Animated.neq(springToNextItemInDirection, 0), [Animated.add(x, Animated.multiply(itemWidth, springToNextItemInDirection))], [x])], [scrollToValue])], itemWidth)), itemWidth)), Animated.cond(Animated.neq(maxScrollX, 0), [Animated.cond(Animated.greaterThan(x, 0), [Animated.set(snapPoint, 0)], Animated.cond(Animated.lessThan(x, maxScrollX), [Animated.set(snapPoint, maxScrollX)]))]), call([snapPointWithCenter, snapPoint], onScrollEnd)]), helper.tick]),
      stop: helper.stop
    });
  })();
  /**
   * Defines if we should spring or decay based on maxScrollX.
   **/


  const shouldSpringInsteadOfDecay = Animated.block([Animated.cond(Animated.eq(maxScrollX, 0), [0], Animated.cond(Animated.greaterThan(x, 0), [1], Animated.cond(Animated.lessThan(x, maxScrollX), [1], [0])))]);
  /**
   * Handles decay related stuff.
   **/

  const decayState = (() => {
    const helper = decayHelper(x, velocity, decayConfig && decayConfig.deceleration ? decayConfig.deceleration : 0.997);
    /**
     * Defines if the decay ended up going past our min/max x (if set)
     **/

    let overshot = new Animated.Value(0);
    return _objectSpread({}, helper, {
      overshot,
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(overshot, 0), helper.tick], [Animated.cond(Animated.and(Animated.neq(maxScrollX, 0), Animated.or(Animated.greaterThan(x, 0), Animated.lessThan(x, maxScrollX))), [Animated.set(overshot, 1), Animated.set(velocity, helper.velocity), helper.stop], [helper.tick])])])
    });
  })();
  /**
   * Handles everything related to gestures
   **/


  const gestureState = (() => {
    let newX = new Animated.Value(0);
    let pointX = new Animated.Value(0);
    let distX = new Animated.Value(0);
    let deltaX = new Animated.Value(0);
    let startTime = new Animated.Value(0);
    let endTime = new Animated.Value(0);
    let data = {
      x: new Animated.Value(0),
      state: new Animated.Value(-1),
      velocityX: new Animated.Value(0)
    };
    /**
     * Handler for when the gesture starts.
     **/

    let start = Animated.block([startClock(baseClock), Animated.set(logicState, LogicState.GESTURE), Animated.set(distX, 0), Animated.set(startTime, baseClock), Animated.set(pointX, data.x)]);
    /**
     * Handler for gesture move.
     **/

    let move = Animated.block([Animated.set(deltaX, Animated.sub(data.x, pointX)), Animated.set(pointX, data.x), Animated.set(distX, Animated.add(distX, deltaX)), Animated.set(newX, Animated.add(x, deltaX)), Animated.cond(Animated.neq(maxScrollX, 0), [Animated.cond(Animated.or(Animated.greaterThan(newX, 0), Animated.lessThan(newX, maxScrollX)), [Animated.set(newX, Animated.add(x, Animated.divide(deltaX, 3)))])]), Animated.set(x, newX)]);
    /**
     * Handler for gesture end
     **/

    let end = Animated.block([stopClock(baseClock), Animated.set(endTime, baseClock), Animated.set(velocity, data.velocityX), Animated.cond(Animated.or(Animated.eq(shouldSpringInsteadOfDecay, 1), Animated.lessThan(abs(velocity), 3000)), [Animated.set(springToNextItemInDirection, Animated.divide(abs(velocity), velocity)), Animated.set(logicState, LogicState.SPRING), springState.tick], [Animated.set(springToNextItemInDirection, 0), Animated.set(logicState, LogicState.DECAY), decayState.tick])]);
    return {
      data,
      start,
      move,
      end
    };
  })();
  /**
   * Primary logic to determine the value of `x`.
   **/


  const calculatedTransX = Animated.block([Animated.cond(Animated.eq(logicState, LogicState.IDLE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.start])], Animated.cond(Animated.eq(logicState, LogicState.GESTURE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.move], Animated.cond(Animated.eq(gestureState.data.state, State.END), [gestureState.end]))], [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [decayState.stop, springState.stop, gestureState.start], Animated.cond(Animated.eq(logicState, LogicState.DECAY), [springState.stop, decayState.tick, Animated.cond(Animated.eq(decayState.finished, 1), [Animated.cond(Animated.eq(decayState.overshot, 0), [Animated.set(velocity, 0)]), Animated.set(logicState, LogicState.SPRING), springState.tick])], Animated.cond(Animated.eq(logicState, LogicState.SPRING), [decayState.stop, springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])], Animated.cond(Animated.eq(logicState, LogicState.SCROLL_TO), [Animated.cond(Animated.eq(scrollToWithAnimation, 0), [decayState.stop, springState.stop, Animated.set(x, scrollToValue), Animated.set(logicState, LogicState.IDLE), call([xWithCenter, x], onScrollEnd)], [Animated.set(velocity, 0), Animated.cond(Animated.or(Animated.neq(diff(scrollToValue), 0), Animated.neq(previousLogicState, logicState)), [decayState.stop, springState.stop]), springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])])]))))])), Animated.cond(Animated.and(Animated.neq(diff(logicState), 0), Animated.eq(logicState, LogicState.IDLE)), [call([xWithCenter, logicState], onScrollSettled)]), call([xWithCenter], onXChange), Animated.set(previousLogicState, logicState), xWithCenter]);
  const gestureHandler = Animated.event([{
    nativeEvent: gestureState.data
  }]);
  const result = Object.create(eventEmitter);
  Object.assign(result, {
    x: calculatedTransX,
    gestureHandler,

    updateItemWidth(value) {
      itemWidth.setValue(value);
    },

    updateWrapperWidth(value) {
      wrapperWidth.setValue(value);
    },

    updateCenterScroll(value) {
      centerScroll.setValue(value ? 1 : 0);
    },

    updateMaxScroll(value) {
      maxScrollX.setValue(value);
    },

    scrollTo(value, withAnimation = true) {
      scrollToValue.setValue(value);
      scrollToWithAnimation.setValue(withAnimation ? 1 : 0);
      logicState.setValue(LogicState.SCROLL_TO);
    }

  });
  return result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9BbmltYXRpb25Mb2dpYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJTdGF0ZSIsIkV2ZW50RW1pdHRlciIsImRlY2F5SGVscGVyIiwic3ByaW5nSGVscGVyIiwiQW5pbWF0ZWQiLCJjYWxsIiwic3RvcENsb2NrIiwic3RhcnRDbG9jayIsImRpZmYiLCJkZWJ1ZyIsImFicyIsInJvdW5kIiwiTG9naWNTdGF0ZSIsIklETEUiLCJERUNBWSIsIlNQUklORyIsIkdFU1RVUkUiLCJTQ1JPTExfVE8iLCJnZXRPciIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiQW5pbWF0aW9uTG9naWMiLCJvcHRpb25zIiwic3ByaW5nQ29uZmlnIiwiZGVjYXlDb25maWciLCJldmVudEVtaXR0ZXIiLCJiYXNlQ2xvY2siLCJDbG9jayIsImxvZ2ljU3RhdGUiLCJWYWx1ZSIsInByZXZpb3VzTG9naWNTdGF0ZSIsIngiLCJzdGFydGluZ1Bvc2l0aW9uIiwidmVsb2NpdHkiLCJpdGVtV2lkdGgiLCJ3cmFwcGVyV2lkdGgiLCJjZW50ZXIiLCJjZW50ZXJTY3JvbGwiLCJ4V2l0aENlbnRlciIsIm1heFNjcm9sbFgiLCJtYXhTY3JvbGwiLCJzY3JvbGxUb1ZhbHVlIiwic2Nyb2xsVG9XaXRoQW5pbWF0aW9uIiwic3ByaW5nVG9OZXh0SXRlbUluRGlyZWN0aW9uIiwib25YQ2hhbmdlIiwiZW1pdCIsIm9uU2Nyb2xsRW5kIiwic2Nyb2xsRW5kWFdpdGhDZW50ZXIiLCJzY3JvbGxFbmRYIiwib25TY3JvbGxTZXR0bGVkIiwic3ByaW5nU3RhdGUiLCJzbmFwUG9pbnQiLCJzbmFwUG9pbnRXaXRoQ2VudGVyIiwiaGVscGVyIiwidGljayIsInJ1bm5pbmciLCJzdG9wIiwic2hvdWxkU3ByaW5nSW5zdGVhZE9mRGVjYXkiLCJkZWNheVN0YXRlIiwiZGVjZWxlcmF0aW9uIiwib3ZlcnNob3QiLCJnZXN0dXJlU3RhdGUiLCJuZXdYIiwicG9pbnRYIiwiZGlzdFgiLCJkZWx0YVgiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZGF0YSIsInN0YXRlIiwidmVsb2NpdHlYIiwic3RhcnQiLCJtb3ZlIiwiZW5kIiwiY2FsY3VsYXRlZFRyYW5zWCIsIkFDVElWRSIsIkVORCIsImZpbmlzaGVkIiwiZ2VzdHVyZUhhbmRsZXIiLCJldmVudCIsIm5hdGl2ZUV2ZW50IiwicmVzdWx0IiwiT2JqZWN0IiwiY3JlYXRlIiwiYXNzaWduIiwidXBkYXRlSXRlbVdpZHRoIiwic2V0VmFsdWUiLCJ1cGRhdGVXcmFwcGVyV2lkdGgiLCJ1cGRhdGVDZW50ZXJTY3JvbGwiLCJ1cGRhdGVNYXhTY3JvbGwiLCJzY3JvbGxUbyIsIndpdGhBbmltYXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBR0EsU0FBUUEsS0FBUixRQUFvQiw4QkFBcEI7QUFDQSxPQUFPQyxZQUFQLE1BQXlCLFFBQXpCO0FBQ0EsU0FBUUMsV0FBUixFQUFxQkMsWUFBckIsUUFBd0MscUJBQXhDO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQix5QkFBckI7QUFDQSxNQUFNO0FBQUNDLEVBQUFBLElBQUQ7QUFBT0MsRUFBQUEsU0FBUDtBQUFrQkMsRUFBQUEsVUFBbEI7QUFBOEJDLEVBQUFBLElBQTlCO0FBQW9DQyxFQUFBQSxLQUFwQztBQUEyQ0MsRUFBQUEsR0FBM0M7QUFBZ0RDLEVBQUFBO0FBQWhELElBQXlEUCxRQUEvRDtBQUVBLE1BQU1RLFVBQVUsR0FBRztBQUNsQkMsRUFBQUEsSUFBSSxFQUFFLENBRFk7QUFFbEJDLEVBQUFBLEtBQUssRUFBRSxDQUZXO0FBR2xCQyxFQUFBQSxNQUFNLEVBQUUsQ0FIVTtBQUlsQkMsRUFBQUEsT0FBTyxFQUFFLENBSlM7QUFLbEJDLEVBQUFBLFNBQVMsRUFBRTtBQUxPLENBQW5COztBQVFBLFNBQVNDLEtBQVQsQ0FBZUMsS0FBZixFQUFzQkMsWUFBdEIsRUFBb0M7QUFDbkMsTUFBSUQsS0FBSyxJQUFJLElBQWIsRUFBbUI7QUFDbEIsV0FBT0EsS0FBUDtBQUNBLEdBRkQsTUFFTztBQUNOLFdBQU9DLFlBQVA7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LEVBQVE7QUFDekJrQixNQUFBQSxZQUFZLENBQUNpRCxRQUFiLENBQXNCbkUsS0FBSyxHQUFHLENBQUgsR0FBTyxDQUFsQztBQUNBLEtBWG9COztBQVlyQnNFLElBQUFBLGVBQWUsQ0FBQ3RFLEtBQUQsRUFBUTtBQUN0Qm9CLE1BQUFBLFVBQVUsQ0FBQytDLFFBQVgsQ0FBb0JuRSxLQUFwQjtBQUNBLEtBZG9COztBQWVyQnVFLElBQUFBLFFBQVEsQ0FBQ3ZFLEtBQUQsRUFBUXdFLGFBQWEsR0FBRyxJQUF4QixFQUE4QjtBQUNyQ2xELE1BQUFBLGFBQWEsQ0FBQzZDLFFBQWQsQ0FBdUJuRSxLQUF2QjtBQUNBdUIsTUFBQUEscUJBQXFCLENBQUM0QyxRQUF0QixDQUErQkssYUFBYSxHQUFHLENBQUgsR0FBTyxDQUFuRDtBQUNBL0QsTUFBQUEsVUFBVSxDQUFDMEQsUUFBWCxDQUFvQjFFLFVBQVUsQ0FBQ0ssU0FBL0I7QUFDQTs7QUFuQm9CLEdBQXRCO0FBc0JBLFNBQU9nRSxNQUFQO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuXG5pbXBvcnQgcmUgZnJvbSAnQGtraXJiYXRza2kvanMtdG8tcmVhbmltYXRlZC5tYWNybyc7XG5pbXBvcnQge1N0YXRlfSBmcm9tICdyZWFjdC1uYXRpdmUtZ2VzdHVyZS1oYW5kbGVyJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7ZGVjYXlIZWxwZXIsIHNwcmluZ0hlbHBlcn0gZnJvbSAnLi9SZWFuaW1hdGVkSGVscGVycyc7XG5pbXBvcnQgQW5pbWF0ZWQgZnJvbSAncmVhY3QtbmF0aXZlLXJlYW5pbWF0ZWQnO1xuY29uc3Qge2NhbGwsIHN0b3BDbG9jaywgc3RhcnRDbG9jaywgZGlmZiwgZGVidWcsIGFicywgcm91bmR9ID0gQW5pbWF0ZWQ7XG5cbmNvbnN0IExvZ2ljU3RhdGUgPSB7XG5cdElETEU6IDAsXG5cdERFQ0FZOiAxLFxuXHRTUFJJTkc6IDIsXG5cdEdFU1RVUkU6IDMsXG5cdFNDUk9MTF9UTzogNCxcbn07XG5cbmZ1bmN0aW9uIGdldE9yKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblx0aWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbmltYXRpb25Mb2dpYyhvcHRpb25zID0ge30pIHtcblx0Y29uc3Qge3NwcmluZ0NvbmZpZywgZGVjYXlDb25maWd9ID0gb3B0aW9ucztcblx0Y29uc3QgZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHQvKipcblx0ICogVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB2ZWxvY2l0eS4gVGhlIGNsb2NrIGlzIHN0YXJ0ZWQgYW5kIHN0b3BwZWQsXG5cdCAqIGFuZCB0aGUgdGltZSBpbiBiZXR3ZWVuIHN0YXJ0IGFuZCBzdG9wcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB2ZWxvY2l0eS5cblx0ICoqL1xuXHRsZXQgYmFzZUNsb2NrID0gbmV3IEFuaW1hdGVkLkNsb2NrKCk7XG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2Ygb3VyIHByaW1hcnkgbG9naWNcblx0ICoqL1xuXHRsZXQgbG9naWNTdGF0ZSA9IG5ldyBBbmltYXRlZC5WYWx1ZShMb2dpY1N0YXRlLklETEUpO1xuXHRsZXQgcHJldmlvdXNMb2dpY1N0YXRlID0gbmV3IEFuaW1hdGVkLlZhbHVlKExvZ2ljU3RhdGUuSURMRSk7XG5cblx0bGV0IHggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoZ2V0T3Iob3B0aW9ucy5zdGFydGluZ1Bvc2l0aW9uLCAwKSk7XG5cdGxldCB2ZWxvY2l0eSA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHRsZXQgaXRlbVdpZHRoID0gbmV3IEFuaW1hdGVkLlZhbHVlKGdldE9yKG9wdGlvbnMuaXRlbVdpZHRoLCAwKSk7XG5cdGxldCB3cmFwcGVyV2lkdGggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoZ2V0T3Iob3B0aW9ucy53cmFwcGVyV2lkdGgsIDApKTtcblxuXHQvKipcblx0ICogSG9sZHMgdGhlIGNlbnRlciBvZmZzZXRcblx0ICoqL1xuXHRsZXQgY2VudGVyID0gcmUoKHdyYXBwZXJXaWR0aCArIGl0ZW1XaWR0aCkgLyAyKTtcblx0bGV0IGNlbnRlclNjcm9sbCA9IG5ldyBBbmltYXRlZC5WYWx1ZShcblx0XHRnZXRPcihvcHRpb25zLmNlbnRlclNjcm9sbCwgZmFsc2UpID8gMSA6IDAsXG5cdCk7XG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgdmFsdWUgb2YgWCArIHRoZSBjZW50ZXIgb2Zmc2V0IChpZiBjZW50ZXJTY3JvbGwgaXMgMSkuXG5cdCAqKi9cblx0bGV0IHhXaXRoQ2VudGVyID0gcmUoKCkgPT4ge1xuXHRcdGlmIChjZW50ZXJTY3JvbGwgPT09IDEpIHtcblx0XHRcdHggKyBjZW50ZXIgLSBpdGVtV2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHg7XG5cdFx0fVxuXHR9KTtcblxuXHRsZXQgbWF4U2Nyb2xsWCA9IG5ldyBBbmltYXRlZC5WYWx1ZShnZXRPcihvcHRpb25zLm1heFNjcm9sbCwgMCkpO1xuXG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgZGVzdGluYXRpb24gc2Nyb2xsIHZhbHVlIHdoZW4gYHNjcm9sbFRvYCBpcyBjYWxsZWQuXG5cdCAqKi9cblx0bGV0IHNjcm9sbFRvVmFsdWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0LyoqXG5cdCAqIEhvbGRzIHdldGhlciBvciBub3QgdGhlIHNjcm9sbCB0byBzaG91bGQgYmUgYW5pbWF0ZWQuXG5cdCAqKi9cblx0bGV0IHNjcm9sbFRvV2l0aEFuaW1hdGlvbiA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHQvKipcblx0ICpcblx0ICoqL1xuXHRsZXQgc3ByaW5nVG9OZXh0SXRlbUluRGlyZWN0aW9uID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSB4IHZhbHVlIGNoYW5nZXMuXG5cdCAqKi9cblx0Y29uc3Qgb25YQ2hhbmdlID0gdmFsdWUgPT4ge1xuXHRcdGV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB2YWx1ZVswXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIHNjcm9sbCBlbmRzLlxuXHQgKiovXG5cdGNvbnN0IG9uU2Nyb2xsRW5kID0gKFtzY3JvbGxFbmRYV2l0aENlbnRlciwgc2Nyb2xsRW5kWF0pID0+IHtcblx0XHRldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsRW5kJywge1xuXHRcdFx0eFdpdGhDZW50ZXI6IHNjcm9sbEVuZFhXaXRoQ2VudGVyLFxuXHRcdFx0eDogc2Nyb2xsRW5kWCxcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlciBmb3Igd2hlbiB0aGUgc2Nyb2xsIGhhcyBzZXR0bGVkIGFuZCBubyBtb3JlIGFuaW1hdGlvbnMgYXJlIHBsYXlpbmcuXG5cdCAqKi9cblx0Y29uc3Qgb25TY3JvbGxTZXR0bGVkID0gdmFsdWUgPT4ge1xuXHRcdGV2ZW50RW1pdHRlci5lbWl0KCdzY3JvbGxTZXR0bGVkJywgdmFsdWVbMF0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHNwcmluZyByZWxhdGVkIHN0dWZmLlxuXHQgKiovXG5cdGNvbnN0IHNwcmluZ1N0YXRlID0gKCgpID0+IHtcblx0XHRsZXQgc25hcFBvaW50ID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdFx0bGV0IHNuYXBQb2ludFdpdGhDZW50ZXIgPSByZSgoKSA9PiB7XG5cdFx0XHRpZiAoY2VudGVyU2Nyb2xsID09PSAxKSB7XG5cdFx0XHRcdHNuYXBQb2ludCArIGNlbnRlciAtIGl0ZW1XaWR0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNuYXBQb2ludDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGNvbnN0IGhlbHBlciA9IHNwcmluZ0hlbHBlcih4LCBzbmFwUG9pbnQsIHZlbG9jaXR5LCBzcHJpbmdDb25maWcpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdC4uLmhlbHBlcixcblx0XHRcdHRpY2s6IHJlKCgpID0+IHtcblx0XHRcdFx0aWYgKGhlbHBlci5ydW5uaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0c25hcFBvaW50ID1cblx0XHRcdFx0XHRcdHJvdW5kKFxuXHRcdFx0XHRcdFx0XHQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLlNQUklORykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHNwcmluZ1RvTmV4dEl0ZW1JbkRpcmVjdGlvbiAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4ICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpdGVtV2lkdGggKlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3ByaW5nVG9OZXh0SXRlbUluRGlyZWN0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0eDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2Nyb2xsVG9WYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pIC8gaXRlbVdpZHRoLFxuXHRcdFx0XHRcdFx0KSAqIGl0ZW1XaWR0aDtcblx0XHRcdFx0XHRpZiAobWF4U2Nyb2xsWCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0aWYgKHggPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHNuYXBQb2ludCA9IDA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHggPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHRcdFx0XHRcdHNuYXBQb2ludCA9IG1heFNjcm9sbFg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGwoW3NuYXBQb2ludFdpdGhDZW50ZXIsIHNuYXBQb2ludF0sIG9uU2Nyb2xsRW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoZWxwZXIudGljaztcblx0XHRcdH0pLFxuXHRcdFx0c3RvcDogaGVscGVyLnN0b3AsXG5cdFx0fTtcblx0fSkoKTtcblxuXHQvKipcblx0ICogRGVmaW5lcyBpZiB3ZSBzaG91bGQgc3ByaW5nIG9yIGRlY2F5IGJhc2VkIG9uIG1heFNjcm9sbFguXG5cdCAqKi9cblx0Y29uc3Qgc2hvdWxkU3ByaW5nSW5zdGVhZE9mRGVjYXkgPSByZSgoKSA9PiB7XG5cdFx0aWYgKG1heFNjcm9sbFggPT09IDApIHtcblx0XHRcdDA7XG5cdFx0fSBlbHNlIGlmICh4ID4gMCkge1xuXHRcdFx0MTtcblx0XHR9IGVsc2UgaWYgKHggPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHQxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQwO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgZGVjYXkgcmVsYXRlZCBzdHVmZi5cblx0ICoqL1xuXHRjb25zdCBkZWNheVN0YXRlID0gKCgpID0+IHtcblx0XHRjb25zdCBoZWxwZXIgPSBkZWNheUhlbHBlcihcblx0XHRcdHgsXG5cdFx0XHR2ZWxvY2l0eSxcblx0XHRcdGRlY2F5Q29uZmlnICYmIGRlY2F5Q29uZmlnLmRlY2VsZXJhdGlvblxuXHRcdFx0XHQ/IGRlY2F5Q29uZmlnLmRlY2VsZXJhdGlvblxuXHRcdFx0XHQ6IDAuOTk3LFxuXHRcdCk7XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBpZiB0aGUgZGVjYXkgZW5kZWQgdXAgZ29pbmcgcGFzdCBvdXIgbWluL21heCB4IChpZiBzZXQpXG5cdFx0ICoqL1xuXHRcdGxldCBvdmVyc2hvdCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Li4uaGVscGVyLFxuXHRcdFx0b3ZlcnNob3QsXG5cdFx0XHR0aWNrOiByZSgoKSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBydW5uaW5nICxyZXNldCBzdHVmZi5cblx0XHRcdFx0aWYgKGhlbHBlci5ydW5uaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gUmVzZXQgb3ZlcnNob3QgdG8gMFxuXHRcdFx0XHRcdG92ZXJzaG90ID0gMDtcblx0XHRcdFx0XHRoZWxwZXIudGljaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAobWF4U2Nyb2xsWCAhPT0gMCAmJiAoeCA+IDAgfHwgeCA8IG1heFNjcm9sbFgpKSB7XG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgbWF4U2Nyb2xsIHNldCBhbmQgd2Ugd2VudCBwYXNzZWQgaXQsIHNldCBvdmVyc2hvdCB0byAxLlxuXHRcdFx0XHRcdFx0b3ZlcnNob3QgPSAxO1xuXHRcdFx0XHRcdFx0Ly8gU2V0IG91ciB2ZWxvY2l0eSB0byB0aGUgZGVjYXkncy5cblx0XHRcdFx0XHRcdHZlbG9jaXR5ID0gaGVscGVyLnZlbG9jaXR5O1xuXHRcdFx0XHRcdFx0aGVscGVyLnN0b3A7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGhlbHBlci50aWNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0fTtcblx0fSkoKTtcblx0LyoqXG5cdCAqIEhhbmRsZXMgZXZlcnl0aGluZyByZWxhdGVkIHRvIGdlc3R1cmVzXG5cdCAqKi9cblx0Y29uc3QgZ2VzdHVyZVN0YXRlID0gKCgpID0+IHtcblx0XHRsZXQgbmV3WCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgcG9pbnRYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBkaXN0WCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgZGVsdGFYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBzdGFydFRpbWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IGVuZFRpbWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0XHRsZXQgZGF0YSA9IHtcblx0XHRcdHg6IG5ldyBBbmltYXRlZC5WYWx1ZSgwKSxcblx0XHRcdHN0YXRlOiBuZXcgQW5pbWF0ZWQuVmFsdWUoLTEpLFxuXHRcdFx0dmVsb2NpdHlYOiBuZXcgQW5pbWF0ZWQuVmFsdWUoMCksXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLlxuXHRcdCAqKi9cblx0XHRsZXQgc3RhcnQgPSByZSgoKSA9PiB7XG5cdFx0XHRzdGFydENsb2NrKGJhc2VDbG9jayk7XG5cdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5HRVNUVVJFO1xuXHRcdFx0ZGlzdFggPSAwO1xuXHRcdFx0c3RhcnRUaW1lID0gYmFzZUNsb2NrO1xuXHRcdFx0cG9pbnRYID0gZGF0YS54O1xuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgZ2VzdHVyZSBtb3ZlLlxuXHRcdCAqKi9cblx0XHRsZXQgbW92ZSA9IHJlKCgpID0+IHtcblx0XHRcdGRlbHRhWCA9IGRhdGEueCAtIHBvaW50WDtcblxuXHRcdFx0cG9pbnRYID0gZGF0YS54O1xuXHRcdFx0ZGlzdFggPSBkaXN0WCArIGRlbHRhWDtcblx0XHRcdG5ld1ggPSB4ICsgZGVsdGFYO1xuXHRcdFx0Ly8gVGhpcyB3aWxsIGdpdmUgYW4gZWxhc3RpYyBmZWVsIHdoZW4gb3Zlci1zY3JvbGxpbmcsIGFkZGluZyByZXNpc3RhbmNlIHRvIHRoZSBwdWxsLlxuXHRcdFx0aWYgKG1heFNjcm9sbFggIT09IDApIHtcblx0XHRcdFx0aWYgKG5ld1ggPiAwIHx8IG5ld1ggPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHRcdFx0bmV3WCA9IHggKyBkZWx0YVggLyAzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR4ID0gbmV3WDtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGdlc3R1cmUgZW5kXG5cdFx0ICoqL1xuXHRcdGxldCBlbmQgPSByZSgoKSA9PiB7XG5cdFx0XHRzdG9wQ2xvY2soYmFzZUNsb2NrKTtcblx0XHRcdGVuZFRpbWUgPSBiYXNlQ2xvY2s7XG5cdFx0XHR2ZWxvY2l0eSA9IGRhdGEudmVsb2NpdHlYO1xuXHRcdFx0aWYgKHNob3VsZFNwcmluZ0luc3RlYWRPZkRlY2F5ID09PSAxIHx8IGFicyh2ZWxvY2l0eSkgPCAzMDAwKSB7XG5cdFx0XHRcdHNwcmluZ1RvTmV4dEl0ZW1JbkRpcmVjdGlvbiA9IGFicyh2ZWxvY2l0eSkgLyB2ZWxvY2l0eTtcblx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuU1BSSU5HO1xuXHRcdFx0XHRzcHJpbmdTdGF0ZS50aWNrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3ByaW5nVG9OZXh0SXRlbUluRGlyZWN0aW9uID0gMDtcblx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuREVDQVk7XG5cdFx0XHRcdGRlY2F5U3RhdGUudGljaztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB7ZGF0YSwgc3RhcnQsIG1vdmUsIGVuZH07XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIFByaW1hcnkgbG9naWMgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgeGAuXG5cdCAqKi9cblx0Y29uc3QgY2FsY3VsYXRlZFRyYW5zWCA9IHJlKCgpID0+IHtcblx0XHRpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5JRExFKSB7XG5cdFx0XHQvLyBXZSd2ZSBzdGFydGVkIHNjcm9sbGluZ1xuXHRcdFx0aWYgKGdlc3R1cmVTdGF0ZS5kYXRhLnN0YXRlID09PSBTdGF0ZS5BQ1RJVkUpIHtcblx0XHRcdFx0Z2VzdHVyZVN0YXRlLnN0YXJ0O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5HRVNUVVJFKSB7XG5cdFx0XHQvLyBXZSdyZSBzdGlsbCBzY3JvbGxpbmdcblx0XHRcdGlmIChnZXN0dXJlU3RhdGUuZGF0YS5zdGF0ZSA9PT0gU3RhdGUuQUNUSVZFKSB7XG5cdFx0XHRcdGdlc3R1cmVTdGF0ZS5tb3ZlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2Nyb2xsaW5nIGhhcyBlbmRlZFxuXHRcdFx0ZWxzZSBpZiAoZ2VzdHVyZVN0YXRlLmRhdGEuc3RhdGUgPT09IFN0YXRlLkVORCkge1xuXHRcdFx0XHRnZXN0dXJlU3RhdGUuZW5kO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBXZSdyZSBub3QgaWRsZSBhbmQgc2Nyb2xsaW5nIGlzbid0IGFjdGl2ZVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gV2UndmUgc3RhcnRlZCBzY3JvbGxpbmcgYWdhaW5cblx0XHRcdGlmIChnZXN0dXJlU3RhdGUuZGF0YS5zdGF0ZSA9PT0gU3RhdGUuQUNUSVZFKSB7XG5cdFx0XHRcdGRlY2F5U3RhdGUuc3RvcDtcblx0XHRcdFx0c3ByaW5nU3RhdGUuc3RvcDtcblx0XHRcdFx0Z2VzdHVyZVN0YXRlLnN0YXJ0O1xuXHRcdFx0fVxuXHRcdFx0Ly8gV2UncmUgaW4gdGhlIGRlY2F5IHN0YXRlXG5cdFx0XHRlbHNlIGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLkRFQ0FZKSB7XG5cdFx0XHRcdHNwcmluZ1N0YXRlLnN0b3A7XG5cdFx0XHRcdGRlY2F5U3RhdGUudGljaztcblx0XHRcdFx0aWYgKGRlY2F5U3RhdGUuZmluaXNoZWQgPT09IDEpIHtcblx0XHRcdFx0XHRpZiAoZGVjYXlTdGF0ZS5vdmVyc2hvdCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0dmVsb2NpdHkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5TUFJJTkc7XG5cdFx0XHRcdFx0c3ByaW5nU3RhdGUudGljaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gV2UncmUgaW4gdGhlIHNwcmluZyBzdGF0ZVxuXHRcdFx0ZWxzZSBpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5TUFJJTkcpIHtcblx0XHRcdFx0ZGVjYXlTdGF0ZS5zdG9wO1xuXHRcdFx0XHRzcHJpbmdTdGF0ZS50aWNrO1xuXHRcdFx0XHRpZiAoc3ByaW5nU3RhdGUuZmluaXNoZWQgPT09IDEpIHtcblx0XHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5JRExFO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSdyZSBpbiB0aGUgc2Nyb2xsIHRvIHN0YXRlXG5cdFx0XHRlbHNlIGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLlNDUk9MTF9UTykge1xuXHRcdFx0XHRpZiAoc2Nyb2xsVG9XaXRoQW5pbWF0aW9uID09PSAwKSB7XG5cdFx0XHRcdFx0ZGVjYXlTdGF0ZS5zdG9wO1xuXHRcdFx0XHRcdHNwcmluZ1N0YXRlLnN0b3A7XG5cdFx0XHRcdFx0eCA9IHNjcm9sbFRvVmFsdWU7XG5cdFx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuSURMRTtcblx0XHRcdFx0XHRjYWxsKFt4V2l0aENlbnRlciwgeF0sIG9uU2Nyb2xsRW5kKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBTZXQgdmVsb2NpdHkgdG8gMCBzaW5jZSB3ZSdyZSBub3Qgc2Nyb2xsaW5nXG5cdFx0XHRcdFx0dmVsb2NpdHkgPSAwO1xuXHRcdFx0XHRcdC8vIFRoaXMgY2hlY2tzIGlmIHRoZSBzY3JvbGxUb1ZhbHVlIGNoYW5nZWQsIG9yIGlmIHRoZSBzdGF0ZSBjaGFuZ2VkIGZyb20gc3ByaW5nIHRvIHNjcm9sbC5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRkaWZmKHNjcm9sbFRvVmFsdWUpICE9PSAwIHx8XG5cdFx0XHRcdFx0XHRwcmV2aW91c0xvZ2ljU3RhdGUgIT09IGxvZ2ljU3RhdGVcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIFN0b3AgZXZlcnl0aGluZywgcmVzZXR0aW5nIGl0XG5cdFx0XHRcdFx0XHRkZWNheVN0YXRlLnN0b3A7XG5cdFx0XHRcdFx0XHRzcHJpbmdTdGF0ZS5zdG9wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzcHJpbmdTdGF0ZS50aWNrO1xuXHRcdFx0XHRcdGlmIChzcHJpbmdTdGF0ZS5maW5pc2hlZCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuSURMRTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gU2Nyb2xsIGhhcyBzZXR0bGVkXG5cdFx0aWYgKGRpZmYobG9naWNTdGF0ZSkgIT09IDAgJiYgbG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5JRExFKSB7XG5cdFx0XHRjYWxsKFt4V2l0aENlbnRlciwgbG9naWNTdGF0ZV0sIG9uU2Nyb2xsU2V0dGxlZCk7XG5cdFx0fVxuXHRcdC8vIFggaGFzIGNoYW5nZWRcblx0XHRjYWxsKFt4V2l0aENlbnRlcl0sIG9uWENoYW5nZSk7XG5cdFx0cHJldmlvdXNMb2dpY1N0YXRlID0gbG9naWNTdGF0ZTtcblx0XHR4V2l0aENlbnRlcjtcblx0fSk7XG5cblx0Y29uc3QgZ2VzdHVyZUhhbmRsZXIgPSBBbmltYXRlZC5ldmVudChbXG5cdFx0e1xuXHRcdFx0bmF0aXZlRXZlbnQ6IGdlc3R1cmVTdGF0ZS5kYXRhLFxuXHRcdH0sXG5cdF0pO1xuXG5cdGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoZXZlbnRFbWl0dGVyKTtcblxuXHRPYmplY3QuYXNzaWduKHJlc3VsdCwge1xuXHRcdHg6IGNhbGN1bGF0ZWRUcmFuc1gsXG5cdFx0Z2VzdHVyZUhhbmRsZXIsXG5cdFx0dXBkYXRlSXRlbVdpZHRoKHZhbHVlKSB7XG5cdFx0XHRpdGVtV2lkdGguc2V0VmFsdWUodmFsdWUpO1xuXHRcdH0sXG5cdFx0dXBkYXRlV3JhcHBlcldpZHRoKHZhbHVlKSB7XG5cdFx0XHR3cmFwcGVyV2lkdGguc2V0VmFsdWUodmFsdWUpO1xuXHRcdH0sXG5cdFx0dXBkYXRlQ2VudGVyU2Nyb2xsKHZhbHVlKSB7XG5cdFx0XHRjZW50ZXJTY3JvbGwuc2V0VmFsdWUodmFsdWUgPyAxIDogMCk7XG5cdFx0fSxcblx0XHR1cGRhdGVNYXhTY3JvbGwodmFsdWUpIHtcblx0XHRcdG1heFNjcm9sbFguc2V0VmFsdWUodmFsdWUpO1xuXHRcdH0sXG5cdFx0c2Nyb2xsVG8odmFsdWUsIHdpdGhBbmltYXRpb24gPSB0cnVlKSB7XG5cdFx0XHRzY3JvbGxUb1ZhbHVlLnNldFZhbHVlKHZhbHVlKTtcblx0XHRcdHNjcm9sbFRvV2l0aEFuaW1hdGlvbi5zZXRWYWx1ZSh3aXRoQW5pbWF0aW9uID8gMSA6IDApO1xuXHRcdFx0bG9naWNTdGF0ZS5zZXRWYWx1ZShMb2dpY1N0YXRlLlNDUk9MTF9UTyk7XG5cdFx0fSxcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cbiJdfQ==