function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @ts-nocheck
import { State } from 'react-native-gesture-handler';
import EventEmitter from 'events';
import { decayHelper, springHelper } from './ReanimatedHelpers';
import Animated from 'react-native-reanimated';
const {
  call,
  stopClock,
  startClock,
  diff,
  debug,
  round
} = Animated;
const LogicState = {
  IDLE: 0,
  DECAY: 1,
  SPRING: 2,
  GESTURE: 3,
  SCROLL_TO: 4
};
export default function AnimationLogic() {
  const eventEmitter = new EventEmitter();
  const randomValue = new Animated.Value(0);
  /**
   * This is used to determine velocity. The clock is started and stopped,
   * and the time in between start and stops is used to calculate velocity.
   **/

  let baseClock = new Animated.Clock();
  /**
   * Stores the current state of our primary logic
   **/

  let logicState = new Animated.Value(LogicState.IDLE);
  let previousLogicState = new Animated.Value(LogicState.IDLE);
  let x = new Animated.Value(0);
  let velocity = new Animated.Value(0);
  let itemWidth = new Animated.Value(0);
  let wrapperWidth = new Animated.Value(0);
  /**
   * Holds the center offset
   **/

  let center = Animated.divide(Animated.add(wrapperWidth, itemWidth), 2);
  let centerScroll = new Animated.Value(0);
  /**
   * Holds the value of X + the center offset (if centerScroll is 1).
   **/

  let xWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(x, center), itemWidth)], [x])]);
  let maxScrollX = new Animated.Value(0);
  /**
   * Holds the destination scroll value when `scrollTo` is called.
   **/

  let scrollToValue = new Animated.Value(0);
  /**
   * Holds wether or not the scroll to should be animated.
   **/

  let scrollToWithAnimation = new Animated.Value(0);
  /**
   * Handler for when the x value changes.
   **/

  const onXChange = value => {
    eventEmitter.emit('change', value[0]);
  };
  /**
   * Handler for when the scroll ends.
   **/


  const onScrollEnd = ([scrollEndXWithCenter, scrollEndX]) => {
    eventEmitter.emit('scrollEnd', {
      xWithCenter: scrollEndXWithCenter,
      x: scrollEndX
    });
  };
  /**
   * Handler for when the scroll has settled and no more animations are playing.
   **/


  const onScrollSettled = value => {
    eventEmitter.emit('scrollSettled', value[0]);
  };
  /**
   * Handles spring related stuff.
   **/


  const springState = (() => {
    let snapPoint = new Animated.Value(0);
    let snapPointWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(snapPoint, center), itemWidth)], [snapPoint])]);
    const helper = springHelper(x, snapPoint, velocity);
    return _objectSpread({}, helper, {
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(snapPoint, Animated.multiply(round(Animated.divide([Animated.cond(Animated.eq(logicState, LogicState.SPRING), [x], [scrollToValue])], itemWidth)), itemWidth)), Animated.cond(Animated.neq(maxScrollX, 0), [Animated.cond(Animated.greaterThan(x, 0), [Animated.set(snapPoint, 0)], Animated.cond(Animated.lessThan(x, maxScrollX), [Animated.set(snapPoint, maxScrollX)]))]), call([snapPointWithCenter, snapPoint], onScrollEnd)]), helper.tick]),
      stop: helper.stop
    });
  })();
  /**
   * Defines if we should spring or decay based on maxScrollX.
   **/


  const shouldSpringInsteadOfDecay = Animated.block([Animated.cond(Animated.eq(maxScrollX, 0), [0], Animated.cond(Animated.greaterThan(x, 0), [1], Animated.cond(Animated.lessThan(x, maxScrollX), [1], [0])))]);
  /**
   * Handles decay related stuff.
   **/

  const decayState = (() => {
    const helper = decayHelper(x, velocity, 0.997);
    /**
     * Defines if the decay ended up going past our min/max x (if set)
     **/

    let overshot = new Animated.Value(0);
    return _objectSpread({}, helper, {
      overshot,
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(overshot, 0), helper.tick], [Animated.cond(Animated.and(Animated.neq(maxScrollX, 0), Animated.or(Animated.greaterThan(x, 0), Animated.lessThan(x, maxScrollX))), [Animated.set(overshot, 1), Animated.set(velocity, helper.velocity), helper.stop], [helper.tick])])])
    });
  })();
  /**
   * Handles everything related to gestures
   **/


  const gestureState = (() => {
    let newX = new Animated.Value(0);
    let pointX = new Animated.Value(0);
    let distX = new Animated.Value(0);
    let deltaX = new Animated.Value(0);
    let startTime = new Animated.Value(0);
    let endTime = new Animated.Value(0);
    let data = {
      x: new Animated.Value(0),
      state: new Animated.Value(-1)
    };
    /**
     * Handler for when the gesture starts.
     **/

    let start = Animated.block([startClock(baseClock), Animated.set(logicState, LogicState.GESTURE), Animated.set(distX, 0), Animated.set(startTime, baseClock), Animated.set(pointX, data.x)]);
    /**
     * Handler for gesture move.
     **/

    let move = Animated.block([Animated.set(deltaX, Animated.sub(data.x, pointX)), Animated.set(pointX, data.x), Animated.set(distX, Animated.add(distX, deltaX)), Animated.set(newX, Animated.add(x, deltaX)), Animated.cond(Animated.neq(maxScrollX, 0), [Animated.cond(Animated.or(Animated.greaterThan(newX, 0), Animated.lessThan(newX, maxScrollX)), [Animated.set(newX, Animated.add(x, Animated.divide(deltaX, 3)))])]), Animated.set(x, newX)]);
    /**
     * Handler for gesture end
     **/

    let end = Animated.block([stopClock(baseClock), Animated.set(endTime, baseClock), Animated.set(velocity, Animated.multiply(Animated.divide(distX, Animated.sub(endTime, startTime)), 1000)), Animated.cond(Animated.eq(shouldSpringInsteadOfDecay, 0), [Animated.set(logicState, LogicState.DECAY), decayState.tick], [Animated.set(logicState, LogicState.SPRING), springState.tick])]);
    return {
      data,
      start,
      move,
      end
    };
  })();
  /**
   * Primary logic to determine the value of `x`.
   **/


  const calculatedTransX = Animated.block([Animated.cond(Animated.eq(logicState, LogicState.IDLE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.start])], Animated.cond(Animated.eq(logicState, LogicState.GESTURE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.move], Animated.cond(Animated.eq(gestureState.data.state, State.END), [gestureState.end]))], [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [decayState.stop, springState.stop, gestureState.start], Animated.cond(Animated.eq(logicState, LogicState.DECAY), [springState.stop, decayState.tick, Animated.cond(Animated.eq(decayState.finished, 1), [Animated.cond(Animated.eq(decayState.overshot, 0), [Animated.set(velocity, 0)]), Animated.set(logicState, LogicState.SPRING), springState.tick])], Animated.cond(Animated.eq(logicState, LogicState.SPRING), [decayState.stop, springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])], Animated.cond(Animated.eq(logicState, LogicState.SCROLL_TO), [Animated.cond(Animated.eq(scrollToWithAnimation, 0), [decayState.stop, springState.stop, Animated.set(x, scrollToValue), Animated.set(logicState, LogicState.IDLE), call([xWithCenter, x], onScrollEnd)], [Animated.set(velocity, 0), Animated.cond(Animated.or(Animated.neq(diff(scrollToValue), 0), Animated.neq(previousLogicState, logicState)), [decayState.stop, springState.stop]), springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])])]))))])), Animated.cond(Animated.and(Animated.neq(diff(logicState), 0), Animated.eq(logicState, LogicState.IDLE)), [call([xWithCenter, logicState], onScrollSettled)]), call([xWithCenter], onXChange), Animated.set(previousLogicState, logicState), xWithCenter]);
  const gestureHandler = Animated.event([{
    nativeEvent: gestureState.data
  }]);
  const result = Object.create(eventEmitter);
  Object.assign(result, {
    x: calculatedTransX,
    gestureHandler,

    updateItemWidth(value) {
      itemWidth.setValue(value);
    },

    updateWrapperWidth(value) {
      wrapperWidth.setValue(value);
    },

    updateCenterScroll(value) {
      centerScroll.setValue(value ? 1 : 0);
    },

    updateMaxScroll(value) {
      maxScrollX.setValue(value);
    },

    scrollTo(value, withAnimation = true) {
      scrollToValue.setValue(value);
      scrollToWithAnimation.setValue(withAnimation ? 1 : 0);
      logicState.setValue(LogicState.SCROLL_TO);
    }

  });
  return result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9BbmltYXRpb25Mb2dpYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJTdGF0ZSIsIkV2ZW50RW1pdHRlciIsImRlY2F5SGVscGVyIiwic3ByaW5nSGVscGVyIiwiQW5pbWF0ZWQiLCJjYWxsIiwic3RvcENsb2NrIiwic3RhcnRDbG9jayIsImRpZmYiLCJkZWJ1ZyIsInJvdW5kIiwiTG9naWNTdGF0ZSIsIklETEUiLCJERUNBWSIsIlNQUklORyIsIkdFU1RVUkUiLCJTQ1JPTExfVE8iLCJBbmltYXRpb25Mb2dpYyIsImV2ZW50RW1pdHRlciIsInJhbmRvbVZhbHVlIiwiVmFsdWUiLCJiYXNlQ2xvY2siLCJDbG9jayIsImxvZ2ljU3RhdGUiLCJwcmV2aW91c0xvZ2ljU3RhdGUiLCJ4IiwidmVsb2NpdHkiLCJpdGVtV2lkdGgiLCJ3cmFwcGVyV2lkdGgiLCJjZW50ZXIiLCJjZW50ZXJTY3JvbGwiLCJ4V2l0aENlbnRlciIsIm1heFNjcm9sbFgiLCJzY3JvbGxUb1ZhbHVlIiwic2Nyb2xsVG9XaXRoQW5pbWF0aW9uIiwib25YQ2hhbmdlIiwidmFsdWUiLCJlbWl0Iiwib25TY3JvbGxFbmQiLCJzY3JvbGxFbmRYV2l0aENlbnRlciIsInNjcm9sbEVuZFgiLCJvblNjcm9sbFNldHRsZWQiLCJzcHJpbmdTdGF0ZSIsInNuYXBQb2ludCIsInNuYXBQb2ludFdpdGhDZW50ZXIiLCJoZWxwZXIiLCJ0aWNrIiwicnVubmluZyIsInN0b3AiLCJzaG91bGRTcHJpbmdJbnN0ZWFkT2ZEZWNheSIsImRlY2F5U3RhdGUiLCJvdmVyc2hvdCIsImdlc3R1cmVTdGF0ZSIsIm5ld1giLCJwb2ludFgiLCJkaXN0WCIsImRlbHRhWCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJkYXRhIiwic3RhdGUiLCJzdGFydCIsIm1vdmUiLCJlbmQiLCJjYWxjdWxhdGVkVHJhbnNYIiwiQUNUSVZFIiwiRU5EIiwiZmluaXNoZWQiLCJnZXN0dXJlSGFuZGxlciIsImV2ZW50IiwibmF0aXZlRXZlbnQiLCJyZXN1bHQiLCJPYmplY3QiLCJjcmVhdGUiLCJhc3NpZ24iLCJ1cGRhdGVJdGVtV2lkdGgiLCJzZXRWYWx1ZSIsInVwZGF0ZVdyYXBwZXJXaWR0aCIsInVwZGF0ZUNlbnRlclNjcm9sbCIsInVwZGF0ZU1heFNjcm9sbCIsInNjcm9sbFRvIiwid2l0aEFuaW1hdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFHQSxTQUFRQSxLQUFSLFFBQW9CLDhCQUFwQjtBQUNBLE9BQU9DLFlBQVAsTUFBeUIsUUFBekI7QUFDQSxTQUFRQyxXQUFSLEVBQXFCQyxZQUFyQixRQUF3QyxxQkFBeEM7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLHlCQUFyQjtBQUNBLE1BQU07QUFBQ0MsRUFBQUEsSUFBRDtBQUFPQyxFQUFBQSxTQUFQO0FBQWtCQyxFQUFBQSxVQUFsQjtBQUE4QkMsRUFBQUEsSUFBOUI7QUFBb0NDLEVBQUFBLEtBQXBDO0FBQTJDQyxFQUFBQTtBQUEzQyxJQUFvRE4sUUFBMUQ7QUFFQSxNQUFNTyxVQUFVLEdBQUc7QUFDbEJDLEVBQUFBLElBQUksRUFBRSxDQURZO0FBRWxCQyxFQUFBQSxLQUFLLEVBQUUsQ0FGVztBQUdsQkMsRUFBQUEsTUFBTSxFQUFFLENBSFU7QUFJbEJDLEVBQUFBLE9BQU8sRUFBRSxDQUpTO0FBS2xCQyxFQUFBQSxTQUFTLEVBQUU7QUFMTyxDQUFuQjtBQVFBLGVBQWUsU0FBU0MsY0FBVCxHQUEwQjtBQUN4QyxRQUFNQyxZQUFZLEdBQUcsSUFBSWpCLFlBQUosRUFBckI7QUFDQSxRQUFNa0IsV0FBVyxHQUFHLElBQUlmLFFBQVEsQ0FBQ2dCLEtBQWIsQ0FBbUIsQ0FBbkIsQ0FBcEI7QUFDQTs7Ozs7QUFJQSxNQUFJQyxTQUFTLEdBQUcsSUFBSWpCLFFBQVEsQ0FBQ2tCLEtBQWIsRUFBaEI7QUFDQTs7OztBQUdBLE1BQUlDLFVBQVUsR0FBRyxJQUFJbkIsUUFBUSxDQUFDZ0IsS0FBYixDQUFtQlQsVUFBVSxDQUFDQyxJQUE5QixDQUFqQjtBQUNBLE1BQUlZLGtCQUFr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QWxDO0FBQ0EsS0FYb0I7O0FBWXJCMkMsSUFBQUEsZUFBZSxDQUFDM0MsS0FBRCxFQUFRO0FBQ3RCSixNQUFBQSxVQUFVLENBQUM0QyxRQUFYLENBQW9CeEMsS0FBcEI7QUFDQSxLQWRvQjs7QUFlckI0QyxJQUFBQSxRQUFRLENBQUM1QyxLQUFELEVBQVE2QyxhQUFhLEdBQUcsSUFBeEIsRUFBOEI7QUFDckNoRCxNQUFBQSxhQUFhLENBQUMyQyxRQUFkLENBQXVCeEMsS0FBdkI7QUFDQUYsTUFBQUEscUJBQXFCLENBQUMwQyxRQUF0QixDQUErQkssYUFBYSxHQUFHLENBQUgsR0FBTyxDQUFuRDtBQUNBMUQsTUFBQUEsVUFBVSxDQUFDcUQsUUFBWCxDQUFvQmpFLFVBQVUsQ0FBQ0ssU0FBL0I7QUFDQTs7QUFuQm9CLEdBQXRCO0FBc0JBLFNBQU91RCxNQUFQO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtbm9jaGVja1xuXG5pbXBvcnQgcmUgZnJvbSAnQGtraXJiYXRza2kvanMtdG8tcmVhbmltYXRlZC5tYWNybyc7XG5pbXBvcnQge1N0YXRlfSBmcm9tICdyZWFjdC1uYXRpdmUtZ2VzdHVyZS1oYW5kbGVyJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7ZGVjYXlIZWxwZXIsIHNwcmluZ0hlbHBlcn0gZnJvbSAnLi9SZWFuaW1hdGVkSGVscGVycyc7XG5pbXBvcnQgQW5pbWF0ZWQgZnJvbSAncmVhY3QtbmF0aXZlLXJlYW5pbWF0ZWQnO1xuY29uc3Qge2NhbGwsIHN0b3BDbG9jaywgc3RhcnRDbG9jaywgZGlmZiwgZGVidWcsIHJvdW5kfSA9IEFuaW1hdGVkO1xuXG5jb25zdCBMb2dpY1N0YXRlID0ge1xuXHRJRExFOiAwLFxuXHRERUNBWTogMSxcblx0U1BSSU5HOiAyLFxuXHRHRVNUVVJFOiAzLFxuXHRTQ1JPTExfVE86IDQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbmltYXRpb25Mb2dpYygpIHtcblx0Y29uc3QgZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRjb25zdCByYW5kb21WYWx1ZSA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0LyoqXG5cdCAqIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgdmVsb2NpdHkuIFRoZSBjbG9jayBpcyBzdGFydGVkIGFuZCBzdG9wcGVkLFxuXHQgKiBhbmQgdGhlIHRpbWUgaW4gYmV0d2VlbiBzdGFydCBhbmQgc3RvcHMgaXMgdXNlZCB0byBjYWxjdWxhdGUgdmVsb2NpdHkuXG5cdCAqKi9cblx0bGV0IGJhc2VDbG9jayA9IG5ldyBBbmltYXRlZC5DbG9jaygpO1xuXHQvKipcblx0ICogU3RvcmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIG91ciBwcmltYXJ5IGxvZ2ljXG5cdCAqKi9cblx0bGV0IGxvZ2ljU3RhdGUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoTG9naWNTdGF0ZS5JRExFKTtcblx0bGV0IHByZXZpb3VzTG9naWNTdGF0ZSA9IG5ldyBBbmltYXRlZC5WYWx1ZShMb2dpY1N0YXRlLklETEUpO1xuXG5cdGxldCB4ID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRsZXQgdmVsb2NpdHkgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0bGV0IGl0ZW1XaWR0aCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0bGV0IHdyYXBwZXJXaWR0aCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHQvKipcblx0ICogSG9sZHMgdGhlIGNlbnRlciBvZmZzZXRcblx0ICoqL1xuXHRsZXQgY2VudGVyID0gcmUoKHdyYXBwZXJXaWR0aCArIGl0ZW1XaWR0aCkgLyAyKTtcblx0bGV0IGNlbnRlclNjcm9sbCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0LyoqXG5cdCAqIEhvbGRzIHRoZSB2YWx1ZSBvZiBYICsgdGhlIGNlbnRlciBvZmZzZXQgKGlmIGNlbnRlclNjcm9sbCBpcyAxKS5cblx0ICoqL1xuXHRsZXQgeFdpdGhDZW50ZXIgPSByZSgoKSA9PiB7XG5cdFx0aWYgKGNlbnRlclNjcm9sbCA9PT0gMSkge1xuXHRcdFx0eCArIGNlbnRlciAtIGl0ZW1XaWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eDtcblx0XHR9XG5cdH0pO1xuXG5cdGxldCBtYXhTY3JvbGxYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgZGVzdGluYXRpb24gc2Nyb2xsIHZhbHVlIHdoZW4gYHNjcm9sbFRvYCBpcyBjYWxsZWQuXG5cdCAqKi9cblx0bGV0IHNjcm9sbFRvVmFsdWUgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0LyoqXG5cdCAqIEhvbGRzIHdldGhlciBvciBub3QgdGhlIHNjcm9sbCB0byBzaG91bGQgYmUgYW5pbWF0ZWQuXG5cdCAqKi9cblx0bGV0IHNjcm9sbFRvV2l0aEFuaW1hdGlvbiA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHQvKipcblx0ICogSGFuZGxlciBmb3Igd2hlbiB0aGUgeCB2YWx1ZSBjaGFuZ2VzLlxuXHQgKiovXG5cdGNvbnN0IG9uWENoYW5nZSA9IHZhbHVlID0+IHtcblx0XHRldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgdmFsdWVbMF0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSBzY3JvbGwgZW5kcy5cblx0ICoqL1xuXHRjb25zdCBvblNjcm9sbEVuZCA9IChbc2Nyb2xsRW5kWFdpdGhDZW50ZXIsIHNjcm9sbEVuZFhdKSA9PiB7XG5cdFx0ZXZlbnRFbWl0dGVyLmVtaXQoJ3Njcm9sbEVuZCcsIHtcblx0XHRcdHhXaXRoQ2VudGVyOiBzY3JvbGxFbmRYV2l0aENlbnRlcixcblx0XHRcdHg6IHNjcm9sbEVuZFgsXG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIHNjcm9sbCBoYXMgc2V0dGxlZCBhbmQgbm8gbW9yZSBhbmltYXRpb25zIGFyZSBwbGF5aW5nLlxuXHQgKiovXG5cdGNvbnN0IG9uU2Nyb2xsU2V0dGxlZCA9IHZhbHVlID0+IHtcblx0XHRldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsU2V0dGxlZCcsIHZhbHVlWzBdKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBzcHJpbmcgcmVsYXRlZCBzdHVmZi5cblx0ICoqL1xuXHRjb25zdCBzcHJpbmdTdGF0ZSA9ICgoKSA9PiB7XG5cdFx0bGV0IHNuYXBQb2ludCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHRcdGxldCBzbmFwUG9pbnRXaXRoQ2VudGVyID0gcmUoKCkgPT4ge1xuXHRcdFx0aWYgKGNlbnRlclNjcm9sbCA9PT0gMSkge1xuXHRcdFx0XHRzbmFwUG9pbnQgKyBjZW50ZXIgLSBpdGVtV2lkdGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzbmFwUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjb25zdCBoZWxwZXIgPSBzcHJpbmdIZWxwZXIoeCwgc25hcFBvaW50LCB2ZWxvY2l0eSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Li4uaGVscGVyLFxuXHRcdFx0dGljazogcmUoKCkgPT4ge1xuXHRcdFx0XHRpZiAoaGVscGVyLnJ1bm5pbmcgPT09IDApIHtcblx0XHRcdFx0XHRzbmFwUG9pbnQgPVxuXHRcdFx0XHRcdFx0cm91bmQoXG5cdFx0XHRcdFx0XHRcdCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuU1BSSU5HKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR4O1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzY3JvbGxUb1ZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSkgLyBpdGVtV2lkdGgsXG5cdFx0XHRcdFx0XHQpICogaXRlbVdpZHRoO1xuXHRcdFx0XHRcdGlmIChtYXhTY3JvbGxYICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRpZiAoeCA+IDApIHtcblx0XHRcdFx0XHRcdFx0c25hcFBvaW50ID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeCA8IG1heFNjcm9sbFgpIHtcblx0XHRcdFx0XHRcdFx0c25hcFBvaW50ID0gbWF4U2Nyb2xsWDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsbChbc25hcFBvaW50V2l0aENlbnRlciwgc25hcFBvaW50XSwgb25TY3JvbGxFbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhlbHBlci50aWNrO1xuXHRcdFx0fSksXG5cdFx0XHRzdG9wOiBoZWxwZXIuc3RvcCxcblx0XHR9O1xuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGlmIHdlIHNob3VsZCBzcHJpbmcgb3IgZGVjYXkgYmFzZWQgb24gbWF4U2Nyb2xsWC5cblx0ICoqL1xuXHRjb25zdCBzaG91bGRTcHJpbmdJbnN0ZWFkT2ZEZWNheSA9IHJlKCgpID0+IHtcblx0XHRpZiAobWF4U2Nyb2xsWCA9PT0gMCkge1xuXHRcdFx0MDtcblx0XHR9IGVsc2UgaWYgKHggPiAwKSB7XG5cdFx0XHQxO1xuXHRcdH0gZWxzZSBpZiAoeCA8IG1heFNjcm9sbFgpIHtcblx0XHRcdDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdDA7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBkZWNheSByZWxhdGVkIHN0dWZmLlxuXHQgKiovXG5cdGNvbnN0IGRlY2F5U3RhdGUgPSAoKCkgPT4ge1xuXHRcdGNvbnN0IGhlbHBlciA9IGRlY2F5SGVscGVyKHgsIHZlbG9jaXR5LCAwLjk5Nyk7XG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lcyBpZiB0aGUgZGVjYXkgZW5kZWQgdXAgZ29pbmcgcGFzdCBvdXIgbWluL21heCB4IChpZiBzZXQpXG5cdFx0ICoqL1xuXHRcdGxldCBvdmVyc2hvdCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Li4uaGVscGVyLFxuXHRcdFx0b3ZlcnNob3QsXG5cdFx0XHR0aWNrOiByZSgoKSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBydW5uaW5nICxyZXNldCBzdHVmZi5cblx0XHRcdFx0aWYgKGhlbHBlci5ydW5uaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gUmVzZXQgb3ZlcnNob3QgdG8gMFxuXHRcdFx0XHRcdG92ZXJzaG90ID0gMDtcblx0XHRcdFx0XHRoZWxwZXIudGljaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAobWF4U2Nyb2xsWCAhPT0gMCAmJiAoeCA+IDAgfHwgeCA8IG1heFNjcm9sbFgpKSB7XG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgbWF4U2Nyb2xsIHNldCBhbmQgd2Ugd2VudCBwYXNzZWQgaXQsIHNldCBvdmVyc2hvdCB0byAxLlxuXHRcdFx0XHRcdFx0b3ZlcnNob3QgPSAxO1xuXHRcdFx0XHRcdFx0Ly8gU2V0IG91ciB2ZWxvY2l0eSB0byB0aGUgZGVjYXkncy5cblx0XHRcdFx0XHRcdHZlbG9jaXR5ID0gaGVscGVyLnZlbG9jaXR5O1xuXHRcdFx0XHRcdFx0aGVscGVyLnN0b3A7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGhlbHBlci50aWNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0fTtcblx0fSkoKTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBldmVyeXRoaW5nIHJlbGF0ZWQgdG8gZ2VzdHVyZXNcblx0ICoqL1xuXHRjb25zdCBnZXN0dXJlU3RhdGUgPSAoKCkgPT4ge1xuXHRcdGxldCBuZXdYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBwb2ludFggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IGRpc3RYID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBkZWx0YVggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IHN0YXJ0VGltZSA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgZW5kVGltZSA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHRcdGxldCBkYXRhID0ge1xuXHRcdFx0eDogbmV3IEFuaW1hdGVkLlZhbHVlKDApLFxuXHRcdFx0c3RhdGU6IG5ldyBBbmltYXRlZC5WYWx1ZSgtMSksXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIGdlc3R1cmUgc3RhcnRzLlxuXHRcdCAqKi9cblx0XHRsZXQgc3RhcnQgPSByZSgoKSA9PiB7XG5cdFx0XHRzdGFydENsb2NrKGJhc2VDbG9jayk7XG5cdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5HRVNUVVJFO1xuXHRcdFx0ZGlzdFggPSAwO1xuXHRcdFx0c3RhcnRUaW1lID0gYmFzZUNsb2NrO1xuXHRcdFx0cG9pbnRYID0gZGF0YS54O1xuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgZ2VzdHVyZSBtb3ZlLlxuXHRcdCAqKi9cblx0XHRsZXQgbW92ZSA9IHJlKCgpID0+IHtcblx0XHRcdGRlbHRhWCA9IGRhdGEueCAtIHBvaW50WDtcblxuXHRcdFx0cG9pbnRYID0gZGF0YS54O1xuXHRcdFx0ZGlzdFggPSBkaXN0WCArIGRlbHRhWDtcblx0XHRcdG5ld1ggPSB4ICsgZGVsdGFYO1xuXHRcdFx0aWYgKG1heFNjcm9sbFggIT09IDApIHtcblx0XHRcdFx0aWYgKG5ld1ggPiAwIHx8IG5ld1ggPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHRcdFx0bmV3WCA9IHggKyBkZWx0YVggLyAzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR4ID0gbmV3WDtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGdlc3R1cmUgZW5kXG5cdFx0ICoqL1xuXHRcdGxldCBlbmQgPSByZSgoKSA9PiB7XG5cdFx0XHRzdG9wQ2xvY2soYmFzZUNsb2NrKTtcblx0XHRcdGVuZFRpbWUgPSBiYXNlQ2xvY2s7XG5cdFx0XHR2ZWxvY2l0eSA9IChkaXN0WCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSkgKiAxMDAwO1xuXHRcdFx0aWYgKHNob3VsZFNwcmluZ0luc3RlYWRPZkRlY2F5ID09PSAwKSB7XG5cdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLkRFQ0FZO1xuXHRcdFx0XHRkZWNheVN0YXRlLnRpY2s7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5TUFJJTkc7XG5cdFx0XHRcdHNwcmluZ1N0YXRlLnRpY2s7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4ge2RhdGEsIHN0YXJ0LCBtb3ZlLCBlbmR9O1xuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBQcmltYXJ5IGxvZ2ljIHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHhgLlxuXHQgKiovXG5cdGNvbnN0IGNhbGN1bGF0ZWRUcmFuc1ggPSByZSgoKSA9PiB7XG5cdFx0aWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuSURMRSkge1xuXHRcdFx0Ly8gV2UndmUgc3RhcnRlZCBzY3JvbGxpbmdcblx0XHRcdGlmIChnZXN0dXJlU3RhdGUuZGF0YS5zdGF0ZSA9PT0gU3RhdGUuQUNUSVZFKSB7XG5cdFx0XHRcdGdlc3R1cmVTdGF0ZS5zdGFydDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuR0VTVFVSRSkge1xuXHRcdFx0Ly8gV2UncmUgc3RpbGwgc2Nyb2xsaW5nXG5cdFx0XHRpZiAoZ2VzdHVyZVN0YXRlLmRhdGEuc3RhdGUgPT09IFN0YXRlLkFDVElWRSkge1xuXHRcdFx0XHRnZXN0dXJlU3RhdGUubW92ZTtcblx0XHRcdH1cblx0XHRcdC8vIFNjcm9sbGluZyBoYXMgZW5kZWRcblx0XHRcdGVsc2UgaWYgKGdlc3R1cmVTdGF0ZS5kYXRhLnN0YXRlID09PSBTdGF0ZS5FTkQpIHtcblx0XHRcdFx0Z2VzdHVyZVN0YXRlLmVuZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gV2UncmUgbm90IGlkbGUgYW5kIHNjcm9sbGluZyBpc24ndCBhY3RpdmVcblx0XHRlbHNlIHtcblx0XHRcdC8vIFdlJ3ZlIHN0YXJ0ZWQgc2Nyb2xsaW5nIGFnYWluXG5cdFx0XHRpZiAoZ2VzdHVyZVN0YXRlLmRhdGEuc3RhdGUgPT09IFN0YXRlLkFDVElWRSkge1xuXHRcdFx0XHRkZWNheVN0YXRlLnN0b3A7XG5cdFx0XHRcdHNwcmluZ1N0YXRlLnN0b3A7XG5cdFx0XHRcdGdlc3R1cmVTdGF0ZS5zdGFydDtcblx0XHRcdH1cblx0XHRcdC8vIFdlJ3JlIGluIHRoZSBkZWNheSBzdGF0ZVxuXHRcdFx0ZWxzZSBpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5ERUNBWSkge1xuXHRcdFx0XHRzcHJpbmdTdGF0ZS5zdG9wO1xuXHRcdFx0XHRkZWNheVN0YXRlLnRpY2s7XG5cdFx0XHRcdGlmIChkZWNheVN0YXRlLmZpbmlzaGVkID09PSAxKSB7XG5cdFx0XHRcdFx0aWYgKGRlY2F5U3RhdGUub3ZlcnNob3QgPT09IDApIHtcblx0XHRcdFx0XHRcdHZlbG9jaXR5ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuU1BSSU5HO1xuXHRcdFx0XHRcdHNwcmluZ1N0YXRlLnRpY2s7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFdlJ3JlIGluIHRoZSBzcHJpbmcgc3RhdGVcblx0XHRcdGVsc2UgaWYgKGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuU1BSSU5HKSB7XG5cdFx0XHRcdGRlY2F5U3RhdGUuc3RvcDtcblx0XHRcdFx0c3ByaW5nU3RhdGUudGljaztcblx0XHRcdFx0aWYgKHNwcmluZ1N0YXRlLmZpbmlzaGVkID09PSAxKSB7XG5cdFx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuSURMRTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gV2UncmUgaW4gdGhlIHNjcm9sbCB0byBzdGF0ZVxuXHRcdFx0ZWxzZSBpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5TQ1JPTExfVE8pIHtcblx0XHRcdFx0aWYgKHNjcm9sbFRvV2l0aEFuaW1hdGlvbiA9PT0gMCkge1xuXHRcdFx0XHRcdGRlY2F5U3RhdGUuc3RvcDtcblx0XHRcdFx0XHRzcHJpbmdTdGF0ZS5zdG9wO1xuXHRcdFx0XHRcdHggPSBzY3JvbGxUb1ZhbHVlO1xuXHRcdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLklETEU7XG5cdFx0XHRcdFx0Y2FsbChbeFdpdGhDZW50ZXIsIHhdLCBvblNjcm9sbEVuZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gU2V0IHZlbG9jaXR5IHRvIDAgc2luY2Ugd2UncmUgbm90IHNjcm9sbGluZ1xuXHRcdFx0XHRcdHZlbG9jaXR5ID0gMDtcblx0XHRcdFx0XHQvLyBUaGlzIGNoZWNrcyBpZiB0aGUgc2Nyb2xsVG9WYWx1ZSBjaGFuZ2VkLCBvciBpZiB0aGUgc3RhdGUgY2hhbmdlZCBmcm9tIHNwcmluZyB0byBzY3JvbGwuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0ZGlmZihzY3JvbGxUb1ZhbHVlKSAhPT0gMCB8fFxuXHRcdFx0XHRcdFx0cHJldmlvdXNMb2dpY1N0YXRlICE9PSBsb2dpY1N0YXRlXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQvLyBTdG9wIGV2ZXJ5dGhpbmcsIHJlc2V0dGluZyBpdFxuXHRcdFx0XHRcdFx0ZGVjYXlTdGF0ZS5zdG9wO1xuXHRcdFx0XHRcdFx0c3ByaW5nU3RhdGUuc3RvcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3ByaW5nU3RhdGUudGljaztcblx0XHRcdFx0XHRpZiAoc3ByaW5nU3RhdGUuZmluaXNoZWQgPT09IDEpIHtcblx0XHRcdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLklETEU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIFNjcm9sbCBoYXMgc2V0dGxlZFxuXHRcdGlmIChkaWZmKGxvZ2ljU3RhdGUpICE9PSAwICYmIGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuSURMRSkge1xuXHRcdFx0Y2FsbChbeFdpdGhDZW50ZXIsIGxvZ2ljU3RhdGVdLCBvblNjcm9sbFNldHRsZWQpO1xuXHRcdH1cblx0XHQvLyBYIGhhcyBjaGFuZ2VkXG5cdFx0Y2FsbChbeFdpdGhDZW50ZXJdLCBvblhDaGFuZ2UpO1xuXHRcdHByZXZpb3VzTG9naWNTdGF0ZSA9IGxvZ2ljU3RhdGU7XG5cdFx0eFdpdGhDZW50ZXI7XG5cdH0pO1xuXG5cdGNvbnN0IGdlc3R1cmVIYW5kbGVyID0gQW5pbWF0ZWQuZXZlbnQoW1xuXHRcdHtcblx0XHRcdG5hdGl2ZUV2ZW50OiBnZXN0dXJlU3RhdGUuZGF0YSxcblx0XHR9LFxuXHRdKTtcblxuXHRjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKGV2ZW50RW1pdHRlcik7XG5cblx0T2JqZWN0LmFzc2lnbihyZXN1bHQsIHtcblx0XHR4OiBjYWxjdWxhdGVkVHJhbnNYLFxuXHRcdGdlc3R1cmVIYW5kbGVyLFxuXHRcdHVwZGF0ZUl0ZW1XaWR0aCh2YWx1ZSkge1xuXHRcdFx0aXRlbVdpZHRoLnNldFZhbHVlKHZhbHVlKTtcblx0XHR9LFxuXHRcdHVwZGF0ZVdyYXBwZXJXaWR0aCh2YWx1ZSkge1xuXHRcdFx0d3JhcHBlcldpZHRoLnNldFZhbHVlKHZhbHVlKTtcblx0XHR9LFxuXHRcdHVwZGF0ZUNlbnRlclNjcm9sbCh2YWx1ZSkge1xuXHRcdFx0Y2VudGVyU2Nyb2xsLnNldFZhbHVlKHZhbHVlID8gMSA6IDApO1xuXHRcdH0sXG5cdFx0dXBkYXRlTWF4U2Nyb2xsKHZhbHVlKSB7XG5cdFx0XHRtYXhTY3JvbGxYLnNldFZhbHVlKHZhbHVlKTtcblx0XHR9LFxuXHRcdHNjcm9sbFRvKHZhbHVlLCB3aXRoQW5pbWF0aW9uID0gdHJ1ZSkge1xuXHRcdFx0c2Nyb2xsVG9WYWx1ZS5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHRzY3JvbGxUb1dpdGhBbmltYXRpb24uc2V0VmFsdWUod2l0aEFuaW1hdGlvbiA/IDEgOiAwKTtcblx0XHRcdGxvZ2ljU3RhdGUuc2V0VmFsdWUoTG9naWNTdGF0ZS5TQ1JPTExfVE8pO1xuXHRcdH0sXG5cdH0pO1xuXG5cdHJldHVybiByZXN1bHQ7XG59XG4iXX0=