function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// @ts-nocheck
import { State } from 'react-native-gesture-handler';
import EventEmitter from 'events';
import { decayHelper, springHelper } from './ReanimatedHelpers';
import Animated from 'react-native-reanimated';
const {
  call,
  stopClock,
  startClock,
  diff,
  debug,
  round
} = Animated;
const LogicState = {
  IDLE: 0,
  DECAY: 1,
  SPRING: 2,
  GESTURE: 3,
  SCROLL_TO: 4
};
export default function AnimationLogic() {
  const eventEmitter = new EventEmitter();
  /**
   * This is used to determine velocity. The clock is started and stopped,
   * and the time in between start and stops is used to calculate velocity.
   **/

  let baseClock = new Animated.Clock();
  /**
   * Stores the current state of our primary logic
   **/

  let logicState = new Animated.Value(LogicState.IDLE);
  let previousLogicState = new Animated.Value(LogicState.IDLE);
  let x = new Animated.Value(0);
  let velocity = new Animated.Value(0);
  let itemWidth = new Animated.Value(0);
  let wrapperWidth = new Animated.Value(0);
  /**
   * Holds the center offset
   **/

  let center = Animated.divide(Animated.add(wrapperWidth, itemWidth), 2);
  let centerScroll = new Animated.Value(0);
  /**
   * Holds the value of X + the center offset (if centerScroll is 1).
   **/

  let xWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(x, center), itemWidth)], [x])]);
  let maxScrollX = new Animated.Value(0);
  /**
   * Holds the destination scroll value when `scrollTo` is called.
   **/

  let scrollToValue = new Animated.Value(0);
  /**
   * Holds wether or not the scroll to should be animated.
   **/

  let scrollToWithAnimation = new Animated.Value(0);
  /**
   * Handler for when the x value changes.
   **/

  const onXChange = value => {
    eventEmitter.emit('change', value[0]);
  };
  /**
   * Handler for when the scroll ends.
   **/


  const onScrollEnd = value => {
    eventEmitter.emit('scrollEnd', value[0]);
  };
  /**
   * Handles spring related stuff.
   **/


  const springState = (() => {
    let snapPoint = new Animated.Value(0);
    let snapPointWithCenter = Animated.block([Animated.cond(Animated.eq(centerScroll, 1), [Animated.sub(Animated.add(snapPoint, center), itemWidth)], [snapPoint])]);
    const helper = springHelper(x, snapPoint, velocity);
    return _objectSpread({}, helper, {
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(snapPoint, Animated.multiply(round(Animated.divide([Animated.cond(Animated.eq(logicState, LogicState.SPRING), [x], [scrollToValue])], itemWidth)), itemWidth)), Animated.cond(Animated.neq(maxScrollX, 0), [Animated.cond(Animated.greaterThan(x, 0), [Animated.set(snapPoint, 0)], Animated.cond(Animated.lessThan(x, maxScrollX), [Animated.set(snapPoint, maxScrollX)]))]), call([snapPointWithCenter], onScrollEnd)]), helper.tick]),
      stop: helper.stop
    });
  })();
  /**
   * Defines if we should spring or decay based on maxScrollX.
   **/


  const shouldSpringInsteadOfDecay = Animated.block([Animated.cond(Animated.eq(maxScrollX, 0), [0], Animated.cond(Animated.greaterThan(x, 0), [1], Animated.cond(Animated.lessThan(x, maxScrollX), [1], [0])))]);
  /**
   * Handles decay related stuff.
   **/

  const decayState = (() => {
    const helper = decayHelper(x, velocity, 0.997);
    /**
     * Defines if the decay ended up going past our min/max x (if set)
     **/

    let overshot = new Animated.Value(0);
    return _objectSpread({}, helper, {
      overshot,
      tick: Animated.block([Animated.cond(Animated.eq(helper.running, 0), [Animated.set(overshot, 0), helper.tick], [Animated.cond(Animated.and(Animated.neq(maxScrollX, 0), Animated.or(Animated.greaterThan(x, 0), Animated.lessThan(x, maxScrollX))), [Animated.set(overshot, 1), Animated.set(velocity, helper.velocity), helper.stop], [helper.tick])])])
    });
  })();
  /**
   * Handles everything related to gestures
   **/


  const gestureState = (() => {
    let newX = new Animated.Value(0);
    let pointX = new Animated.Value(0);
    let distX = new Animated.Value(0);
    let deltaX = new Animated.Value(0);
    let startTime = new Animated.Value(0);
    let endTime = new Animated.Value(0);
    let data = {
      x: new Animated.Value(0),
      state: new Animated.Value(-1)
    };
    /**
     * Handler for when the gesture starts.
     **/

    let start = Animated.block([startClock(baseClock), Animated.set(logicState, LogicState.GESTURE), Animated.set(distX, 0), Animated.set(startTime, baseClock), Animated.set(pointX, data.x)]);
    /**
     * Handler for gesture move.
     **/

    let move = Animated.block([Animated.set(deltaX, Animated.sub(data.x, pointX)), Animated.set(pointX, data.x), Animated.set(distX, Animated.add(distX, deltaX)), Animated.set(newX, Animated.add(x, deltaX)), Animated.cond(Animated.neq(maxScrollX, 0), [Animated.cond(Animated.or(Animated.greaterThan(newX, 0), Animated.lessThan(newX, maxScrollX)), [Animated.set(newX, Animated.add(x, Animated.divide(deltaX, 3)))])]), Animated.set(x, newX)]);
    /**
     * Handler for gesture end
     **/

    let end = Animated.block([stopClock(baseClock), Animated.set(endTime, baseClock), Animated.set(velocity, Animated.multiply(Animated.divide(distX, Animated.sub(endTime, startTime)), 1000)), Animated.cond(Animated.eq(shouldSpringInsteadOfDecay, 0), [Animated.set(logicState, LogicState.DECAY), decayState.tick], [Animated.set(logicState, LogicState.SPRING), springState.tick])]);
    return {
      data,
      start,
      move,
      end
    };
  })();
  /**
   * Primary logic to determine the value of `x`.
   **/


  const calculatedTransX = Animated.block([Animated.cond(Animated.eq(logicState, LogicState.IDLE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.start])], Animated.cond(Animated.eq(logicState, LogicState.GESTURE), [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [gestureState.move], Animated.cond(Animated.eq(gestureState.data.state, State.END), [gestureState.end]))], [Animated.cond(Animated.eq(gestureState.data.state, State.ACTIVE), [decayState.stop, springState.stop, gestureState.start], Animated.cond(Animated.eq(logicState, LogicState.DECAY), [springState.stop, decayState.tick, Animated.cond(Animated.eq(decayState.finished, 1), [Animated.cond(Animated.eq(decayState.overshot, 0), [Animated.set(velocity, 0)]), Animated.set(logicState, LogicState.SPRING), springState.tick])], Animated.cond(Animated.eq(logicState, LogicState.SPRING), [decayState.stop, springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])], Animated.cond(Animated.eq(logicState, LogicState.SCROLL_TO), [Animated.cond(Animated.eq(scrollToWithAnimation, 0), [decayState.stop, springState.stop, Animated.set(x, scrollToValue), Animated.set(logicState, LogicState.IDLE)], [Animated.set(velocity, 0), Animated.cond(Animated.or(Animated.neq(previousLogicState, logicState), Animated.neq(diff(scrollToValue), 0)), [decayState.stop, springState.stop]), springState.tick, Animated.cond(Animated.eq(springState.finished, 1), [Animated.set(logicState, LogicState.IDLE)])])]))))])), Animated.cond(Animated.and(Animated.neq(diff(logicState), 0), Animated.eq(logicState, LogicState.IDLE)), [call([xWithCenter, logicState], onScrollEnd)]), call([xWithCenter], onXChange), Animated.set(previousLogicState, logicState), xWithCenter]);
  const gestureHandler = Animated.event([{
    nativeEvent: gestureState.data
  }]);
  const result = Object.create(eventEmitter);
  Object.assign(result, {
    x: calculatedTransX,
    gestureHandler,

    updateItemWidth(value) {
      itemWidth.setValue(value);
    },

    updateWrapperWidth(value) {
      wrapperWidth.setValue(value);
    },

    updateCenterScroll(value) {
      centerScroll.setValue(value ? 1 : 0);
    },

    updateMaxScroll(value) {
      maxScrollX.setValue(value);
    },

    scrollTo(value, withAnimation = true) {
      scrollToValue.setValue(value);
      scrollToWithAnimation.setValue(withAnimation ? 1 : 0);
      logicState.setValue(LogicState.SCROLL_TO);
    }

  });
  return result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9BbmltYXRpb25Mb2dpYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJTdGF0ZSIsIkV2ZW50RW1pdHRlciIsImRlY2F5SGVscGVyIiwic3ByaW5nSGVscGVyIiwiQW5pbWF0ZWQiLCJjYWxsIiwic3RvcENsb2NrIiwic3RhcnRDbG9jayIsImRpZmYiLCJkZWJ1ZyIsInJvdW5kIiwiTG9naWNTdGF0ZSIsIklETEUiLCJERUNBWSIsIlNQUklORyIsIkdFU1RVUkUiLCJTQ1JPTExfVE8iLCJBbmltYXRpb25Mb2dpYyIsImV2ZW50RW1pdHRlciIsImJhc2VDbG9jayIsIkNsb2NrIiwibG9naWNTdGF0ZSIsIlZhbHVlIiwicHJldmlvdXNMb2dpY1N0YXRlIiwieCIsInZlbG9jaXR5IiwiaXRlbVdpZHRoIiwid3JhcHBlcldpZHRoIiwiY2VudGVyIiwiY2VudGVyU2Nyb2xsIiwieFdpdGhDZW50ZXIiLCJtYXhTY3JvbGxYIiwic2Nyb2xsVG9WYWx1ZSIsInNjcm9sbFRvV2l0aEFuaW1hdGlvbiIsIm9uWENoYW5nZSIsInZhbHVlIiwiZW1pdCIsIm9uU2Nyb2xsRW5kIiwic3ByaW5nU3RhdGUiLCJzbmFwUG9pbnQiLCJzbmFwUG9pbnRXaXRoQ2VudGVyIiwiaGVscGVyIiwidGljayIsInJ1bm5pbmciLCJzdG9wIiwic2hvdWxkU3ByaW5nSW5zdGVhZE9mRGVjYXkiLCJkZWNheVN0YXRlIiwib3ZlcnNob3QiLCJnZXN0dXJlU3RhdGUiLCJuZXdYIiwicG9pbnRYIiwiZGlzdFgiLCJkZWx0YVgiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZGF0YSIsInN0YXRlIiwic3RhcnQiLCJtb3ZlIiwiZW5kIiwiY2FsY3VsYXRlZFRyYW5zWCIsIkFDVElWRSIsIkVORCIsImZpbmlzaGVkIiwiZ2VzdHVyZUhhbmRsZXIiLCJldmVudCIsIm5hdGl2ZUV2ZW50IiwicmVzdWx0IiwiT2JqZWN0IiwiY3JlYXRlIiwiYXNzaWduIiwidXBkYXRlSXRlbVdpZHRoIiwic2V0VmFsdWUiLCJ1cGRhdGVXcmFwcGVyV2lkdGgiLCJ1cGRhdGVDZW50ZXJTY3JvbGwiLCJ1cGRhdGVNYXhTY3JvbGwiLCJzY3JvbGxUbyIsIndpdGhBbmltYXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBR0EsU0FBUUEsS0FBUixRQUFvQiw4QkFBcEI7QUFDQSxPQUFPQyxZQUFQLE1BQXlCLFFBQXpCO0FBQ0EsU0FBUUMsV0FBUixFQUFxQkMsWUFBckIsUUFBd0MscUJBQXhDO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQix5QkFBckI7QUFDQSxNQUFNO0FBQUNDLEVBQUFBLElBQUQ7QUFBT0MsRUFBQUEsU0FBUDtBQUFrQkMsRUFBQUEsVUFBbEI7QUFBOEJDLEVBQUFBLElBQTlCO0FBQW9DQyxFQUFBQSxLQUFwQztBQUEyQ0MsRUFBQUE7QUFBM0MsSUFBb0ROLFFBQTFEO0FBRUEsTUFBTU8sVUFBVSxHQUFHO0FBQ2xCQyxFQUFBQSxJQUFJLEVBQUUsQ0FEWTtBQUVsQkMsRUFBQUEsS0FBSyxFQUFFLENBRlc7QUFHbEJDLEVBQUFBLE1BQU0sRUFBRSxDQUhVO0FBSWxCQyxFQUFBQSxPQUFPLEVBQUUsQ0FKUztBQUtsQkMsRUFBQUEsU0FBUyxFQUFFO0FBTE8sQ0FBbkI7QUFRQSxlQUFlLFNBQVNDLGNBQVQsR0FBMEI7QUFDeEMsUUFBTUMsWUFBWSxHQUFHLElBQUlqQixZQUFKLEVBQXJCO0FBRUE7Ozs7O0FBSUEsTUFBSWtCLFNBQVMsR0FBRyxJQUFJZixRQUFRLENBQUNnQixLQUFiLEVBQWhCO0FBQ0E7Ozs7QUFHQSxNQUFJQyxVQUFVLEdBQUcsSUFBSWpCLFFBQVEsQ0FBQ2tCLEtBQWIsQ0FBbUJYLFVBQVUsQ0FBQ0MsSUFBOUIsQ0FBakI7QUFDQSxNQUFJVyxrQkFBa0IsR0FBRyxJQUFJbkIsUUFBUSxDQUFDa0IsS0FBYixDQUFtQlgsVUFBVSxDQUFDQyxJQUE5QixDQUF6QjtBQUVBLE1BQUlZLENBQUMsR0FBRyxJQUFJcEIsUUFBUSxDQUFDa0IsS0FBYixDQUFtQixDQUFuQixDQUFSO0FBQ0EsTUFB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b3J0IHJlIGZyb20gJ0Bra2lyYmF0c2tpL2pzLXRvLXJlYW5pbWF0ZWQubWFjcm8nO1xuaW1wb3J0IHtTdGF0ZX0gZnJvbSAncmVhY3QtbmF0aXZlLWdlc3R1cmUtaGFuZGxlcic7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge2RlY2F5SGVscGVyLCBzcHJpbmdIZWxwZXJ9IGZyb20gJy4vUmVhbmltYXRlZEhlbHBlcnMnO1xuaW1wb3J0IEFuaW1hdGVkIGZyb20gJ3JlYWN0LW5hdGl2ZS1yZWFuaW1hdGVkJztcbmNvbnN0IHtjYWxsLCBzdG9wQ2xvY2ssIHN0YXJ0Q2xvY2ssIGRpZmYsIGRlYnVnLCByb3VuZH0gPSBBbmltYXRlZDtcblxuY29uc3QgTG9naWNTdGF0ZSA9IHtcblx0SURMRTogMCxcblx0REVDQVk6IDEsXG5cdFNQUklORzogMixcblx0R0VTVFVSRTogMyxcblx0U0NST0xMX1RPOiA0LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQW5pbWF0aW9uTG9naWMoKSB7XG5cdGNvbnN0IGV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHQvKipcblx0ICogVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB2ZWxvY2l0eS4gVGhlIGNsb2NrIGlzIHN0YXJ0ZWQgYW5kIHN0b3BwZWQsXG5cdCAqIGFuZCB0aGUgdGltZSBpbiBiZXR3ZWVuIHN0YXJ0IGFuZCBzdG9wcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB2ZWxvY2l0eS5cblx0ICoqL1xuXHRsZXQgYmFzZUNsb2NrID0gbmV3IEFuaW1hdGVkLkNsb2NrKCk7XG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2Ygb3VyIHByaW1hcnkgbG9naWNcblx0ICoqL1xuXHRsZXQgbG9naWNTdGF0ZSA9IG5ldyBBbmltYXRlZC5WYWx1ZShMb2dpY1N0YXRlLklETEUpO1xuXHRsZXQgcHJldmlvdXNMb2dpY1N0YXRlID0gbmV3IEFuaW1hdGVkLlZhbHVlKExvZ2ljU3RhdGUuSURMRSk7XG5cblx0bGV0IHggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdGxldCB2ZWxvY2l0eSA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHRsZXQgaXRlbVdpZHRoID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRsZXQgd3JhcHBlcldpZHRoID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgY2VudGVyIG9mZnNldFxuXHQgKiovXG5cdGxldCBjZW50ZXIgPSByZSgod3JhcHBlcldpZHRoICsgaXRlbVdpZHRoKSAvIDIpO1xuXHRsZXQgY2VudGVyU2Nyb2xsID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHQvKipcblx0ICogSG9sZHMgdGhlIHZhbHVlIG9mIFggKyB0aGUgY2VudGVyIG9mZnNldCAoaWYgY2VudGVyU2Nyb2xsIGlzIDEpLlxuXHQgKiovXG5cdGxldCB4V2l0aENlbnRlciA9IHJlKCgpID0+IHtcblx0XHRpZiAoY2VudGVyU2Nyb2xsID09PSAxKSB7XG5cdFx0XHR4ICsgY2VudGVyIC0gaXRlbVdpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4O1xuXHRcdH1cblx0fSk7XG5cblx0bGV0IG1heFNjcm9sbFggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0LyoqXG5cdCAqIEhvbGRzIHRoZSBkZXN0aW5hdGlvbiBzY3JvbGwgdmFsdWUgd2hlbiBgc2Nyb2xsVG9gIGlzIGNhbGxlZC5cblx0ICoqL1xuXHRsZXQgc2Nyb2xsVG9WYWx1ZSA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblxuXHQvKipcblx0ICogSG9sZHMgd2V0aGVyIG9yIG5vdCB0aGUgc2Nyb2xsIHRvIHNob3VsZCBiZSBhbmltYXRlZC5cblx0ICoqL1xuXHRsZXQgc2Nyb2xsVG9XaXRoQW5pbWF0aW9uID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSB4IHZhbHVlIGNoYW5nZXMuXG5cdCAqKi9cblx0Y29uc3Qgb25YQ2hhbmdlID0gdmFsdWUgPT4ge1xuXHRcdGV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB2YWx1ZVswXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgZm9yIHdoZW4gdGhlIHNjcm9sbCBlbmRzLlxuXHQgKiovXG5cdGNvbnN0IG9uU2Nyb2xsRW5kID0gdmFsdWUgPT4ge1xuXHRcdGV2ZW50RW1pdHRlci5lbWl0KCdzY3JvbGxFbmQnLCB2YWx1ZVswXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgc3ByaW5nIHJlbGF0ZWQgc3R1ZmYuXG5cdCAqKi9cblx0Y29uc3Qgc3ByaW5nU3RhdGUgPSAoKCkgPT4ge1xuXHRcdGxldCBzbmFwUG9pbnQgPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cblx0XHRsZXQgc25hcFBvaW50V2l0aENlbnRlciA9IHJlKCgpID0+IHtcblx0XHRcdGlmIChjZW50ZXJTY3JvbGwgPT09IDEpIHtcblx0XHRcdFx0c25hcFBvaW50ICsgY2VudGVyIC0gaXRlbVdpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c25hcFBvaW50O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgaGVscGVyID0gc3ByaW5nSGVscGVyKHgsIHNuYXBQb2ludCwgdmVsb2NpdHkpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdC4uLmhlbHBlcixcblx0XHRcdHRpY2s6IHJlKCgpID0+IHtcblx0XHRcdFx0aWYgKGhlbHBlci5ydW5uaW5nID09PSAwKSB7XG5cdFx0XHRcdFx0c25hcFBvaW50ID1cblx0XHRcdFx0XHRcdHJvdW5kKFxuXHRcdFx0XHRcdFx0XHQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLlNQUklORykge1xuXHRcdFx0XHRcdFx0XHRcdFx0eDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2Nyb2xsVG9WYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pIC8gaXRlbVdpZHRoLFxuXHRcdFx0XHRcdFx0KSAqIGl0ZW1XaWR0aDtcblx0XHRcdFx0XHRpZiAobWF4U2Nyb2xsWCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0aWYgKHggPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHNuYXBQb2ludCA9IDA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHggPCBtYXhTY3JvbGxYKSB7XG5cdFx0XHRcdFx0XHRcdHNuYXBQb2ludCA9IG1heFNjcm9sbFg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGwoW3NuYXBQb2ludFdpdGhDZW50ZXJdLCBvblNjcm9sbEVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGVscGVyLnRpY2s7XG5cdFx0XHR9KSxcblx0XHRcdHN0b3A6IGhlbHBlci5zdG9wLFxuXHRcdH07XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgaWYgd2Ugc2hvdWxkIHNwcmluZyBvciBkZWNheSBiYXNlZCBvbiBtYXhTY3JvbGxYLlxuXHQgKiovXG5cdGNvbnN0IHNob3VsZFNwcmluZ0luc3RlYWRPZkRlY2F5ID0gcmUoKCkgPT4ge1xuXHRcdGlmIChtYXhTY3JvbGxYID09PSAwKSB7XG5cdFx0XHQwO1xuXHRcdH0gZWxzZSBpZiAoeCA+IDApIHtcblx0XHRcdDE7XG5cdFx0fSBlbHNlIGlmICh4IDwgbWF4U2Nyb2xsWCkge1xuXHRcdFx0MTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0MDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGRlY2F5IHJlbGF0ZWQgc3R1ZmYuXG5cdCAqKi9cblx0Y29uc3QgZGVjYXlTdGF0ZSA9ICgoKSA9PiB7XG5cdFx0Y29uc3QgaGVscGVyID0gZGVjYXlIZWxwZXIoeCwgdmVsb2NpdHksIDAuOTk3KTtcblx0XHQvKipcblx0XHQgKiBEZWZpbmVzIGlmIHRoZSBkZWNheSBlbmRlZCB1cCBnb2luZyBwYXN0IG91ciBtaW4vbWF4IHggKGlmIHNldClcblx0XHQgKiovXG5cdFx0bGV0IG92ZXJzaG90ID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdHJldHVybiB7XG5cdFx0XHQuLi5oZWxwZXIsXG5cdFx0XHRvdmVyc2hvdCxcblx0XHRcdHRpY2s6IHJlKCgpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UncmUgbm90IHJ1bm5pbmcgLHJlc2V0IHN0dWZmLlxuXHRcdFx0XHRpZiAoaGVscGVyLnJ1bm5pbmcgPT09IDApIHtcblx0XHRcdFx0XHQvLyBSZXNldCBvdmVyc2hvdCB0byAwXG5cdFx0XHRcdFx0b3ZlcnNob3QgPSAwO1xuXHRcdFx0XHRcdGhlbHBlci50aWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChtYXhTY3JvbGxYICE9PSAwICYmICh4ID4gMCB8fCB4IDwgbWF4U2Nyb2xsWCkpIHtcblx0XHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBtYXhTY3JvbGwgc2V0IGFuZCB3ZSB3ZW50IHBhc3NlZCBpdCwgc2V0IG92ZXJzaG90IHRvIDEuXG5cdFx0XHRcdFx0XHRvdmVyc2hvdCA9IDE7XG5cdFx0XHRcdFx0XHQvLyBTZXQgb3VyIHZlbG9jaXR5IHRvIHRoZSBkZWNheSdzLlxuXHRcdFx0XHRcdFx0dmVsb2NpdHkgPSBoZWxwZXIudmVsb2NpdHk7XG5cdFx0XHRcdFx0XHRoZWxwZXIuc3RvcDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aGVscGVyLnRpY2s7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHR9O1xuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGV2ZXJ5dGhpbmcgcmVsYXRlZCB0byBnZXN0dXJlc1xuXHQgKiovXG5cdGNvbnN0IGdlc3R1cmVTdGF0ZSA9ICgoKSA9PiB7XG5cdFx0bGV0IG5ld1ggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IHBvaW50WCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgZGlzdFggPSBuZXcgQW5pbWF0ZWQuVmFsdWUoMCk7XG5cdFx0bGV0IGRlbHRhWCA9IG5ldyBBbmltYXRlZC5WYWx1ZSgwKTtcblx0XHRsZXQgc3RhcnRUaW1lID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXHRcdGxldCBlbmRUaW1lID0gbmV3IEFuaW1hdGVkLlZhbHVlKDApO1xuXG5cdFx0bGV0IGRhdGEgPSB7XG5cdFx0XHR4OiBuZXcgQW5pbWF0ZWQuVmFsdWUoMCksXG5cdFx0XHRzdGF0ZTogbmV3IEFuaW1hdGVkLlZhbHVlKC0xKSxcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3Igd2hlbiB0aGUgZ2VzdHVyZSBzdGFydHMuXG5cdFx0ICoqL1xuXHRcdGxldCBzdGFydCA9IHJlKCgpID0+IHtcblx0XHRcdHN0YXJ0Q2xvY2soYmFzZUNsb2NrKTtcblx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLkdFU1RVUkU7XG5cdFx0XHRkaXN0WCA9IDA7XG5cdFx0XHRzdGFydFRpbWUgPSBiYXNlQ2xvY2s7XG5cdFx0XHRwb2ludFggPSBkYXRhLng7XG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciBnZXN0dXJlIG1vdmUuXG5cdFx0ICoqL1xuXHRcdGxldCBtb3ZlID0gcmUoKCkgPT4ge1xuXHRcdFx0ZGVsdGFYID0gZGF0YS54IC0gcG9pbnRYO1xuXG5cdFx0XHRwb2ludFggPSBkYXRhLng7XG5cdFx0XHRkaXN0WCA9IGRpc3RYICsgZGVsdGFYO1xuXHRcdFx0bmV3WCA9IHggKyBkZWx0YVg7XG5cdFx0XHRpZiAobWF4U2Nyb2xsWCAhPT0gMCkge1xuXHRcdFx0XHRpZiAobmV3WCA+IDAgfHwgbmV3WCA8IG1heFNjcm9sbFgpIHtcblx0XHRcdFx0XHRuZXdYID0geCArIGRlbHRhWCAvIDM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHggPSBuZXdYO1xuXHRcdH0pO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgZ2VzdHVyZSBlbmRcblx0XHQgKiovXG5cdFx0bGV0IGVuZCA9IHJlKCgpID0+IHtcblx0XHRcdHN0b3BDbG9jayhiYXNlQ2xvY2spO1xuXHRcdFx0ZW5kVGltZSA9IGJhc2VDbG9jaztcblx0XHRcdHZlbG9jaXR5ID0gKGRpc3RYIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpKSAqIDEwMDA7XG5cdFx0XHRpZiAoc2hvdWxkU3ByaW5nSW5zdGVhZE9mRGVjYXkgPT09IDApIHtcblx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuREVDQVk7XG5cdFx0XHRcdGRlY2F5U3RhdGUudGljaztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZ2ljU3RhdGUgPSBMb2dpY1N0YXRlLlNQUklORztcblx0XHRcdFx0c3ByaW5nU3RhdGUudGljaztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB7ZGF0YSwgc3RhcnQsIG1vdmUsIGVuZH07XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIFByaW1hcnkgbG9naWMgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgeGAuXG5cdCAqKi9cblx0Y29uc3QgY2FsY3VsYXRlZFRyYW5zWCA9IHJlKCgpID0+IHtcblx0XHRpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5JRExFKSB7XG5cdFx0XHQvLyBXZSd2ZSBzdGFydGVkIHNjcm9sbGluZ1xuXHRcdFx0aWYgKGdlc3R1cmVTdGF0ZS5kYXRhLnN0YXRlID09PSBTdGF0ZS5BQ1RJVkUpIHtcblx0XHRcdFx0Z2VzdHVyZVN0YXRlLnN0YXJ0O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5HRVNUVVJFKSB7XG5cdFx0XHQvLyBXZSdyZSBzdGlsbCBzY3JvbGxpbmdcblx0XHRcdGlmIChnZXN0dXJlU3RhdGUuZGF0YS5zdGF0ZSA9PT0gU3RhdGUuQUNUSVZFKSB7XG5cdFx0XHRcdGdlc3R1cmVTdGF0ZS5tb3ZlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2Nyb2xsaW5nIGhhcyBlbmRlZFxuXHRcdFx0ZWxzZSBpZiAoZ2VzdHVyZVN0YXRlLmRhdGEuc3RhdGUgPT09IFN0YXRlLkVORCkge1xuXHRcdFx0XHRnZXN0dXJlU3RhdGUuZW5kO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBXZSdyZSBub3QgaWRsZSBhbmQgc2Nyb2xsaW5nIGlzbid0IGFjdGl2ZVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gV2UndmUgc3RhcnRlZCBzY3JvbGxpbmcgYWdhaW5cblx0XHRcdGlmIChnZXN0dXJlU3RhdGUuZGF0YS5zdGF0ZSA9PT0gU3RhdGUuQUNUSVZFKSB7XG5cdFx0XHRcdGRlY2F5U3RhdGUuc3RvcDtcblx0XHRcdFx0c3ByaW5nU3RhdGUuc3RvcDtcblx0XHRcdFx0Z2VzdHVyZVN0YXRlLnN0YXJ0O1xuXHRcdFx0fVxuXHRcdFx0Ly8gV2UncmUgaW4gdGhlIGRlY2F5IHN0YXRlXG5cdFx0XHRlbHNlIGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLkRFQ0FZKSB7XG5cdFx0XHRcdHNwcmluZ1N0YXRlLnN0b3A7XG5cdFx0XHRcdGRlY2F5U3RhdGUudGljaztcblx0XHRcdFx0aWYgKGRlY2F5U3RhdGUuZmluaXNoZWQgPT09IDEpIHtcblx0XHRcdFx0XHRpZiAoZGVjYXlTdGF0ZS5vdmVyc2hvdCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0dmVsb2NpdHkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5TUFJJTkc7XG5cdFx0XHRcdFx0c3ByaW5nU3RhdGUudGljaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gV2UncmUgaW4gdGhlIHNwcmluZyBzdGF0ZVxuXHRcdFx0ZWxzZSBpZiAobG9naWNTdGF0ZSA9PT0gTG9naWNTdGF0ZS5TUFJJTkcpIHtcblx0XHRcdFx0ZGVjYXlTdGF0ZS5zdG9wO1xuXHRcdFx0XHRzcHJpbmdTdGF0ZS50aWNrO1xuXHRcdFx0XHRpZiAoc3ByaW5nU3RhdGUuZmluaXNoZWQgPT09IDEpIHtcblx0XHRcdFx0XHRsb2dpY1N0YXRlID0gTG9naWNTdGF0ZS5JRExFO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSdyZSBpbiB0aGUgc2Nyb2xsIHRvIHN0YXRlXG5cdFx0XHRlbHNlIGlmIChsb2dpY1N0YXRlID09PSBMb2dpY1N0YXRlLlNDUk9MTF9UTykge1xuXHRcdFx0XHRpZiAoc2Nyb2xsVG9XaXRoQW5pbWF0aW9uID09PSAwKSB7XG5cdFx0XHRcdFx0ZGVjYXlTdGF0ZS5zdG9wO1xuXHRcdFx0XHRcdHNwcmluZ1N0YXRlLnN0b3A7XG5cdFx0XHRcdFx0eCA9IHNjcm9sbFRvVmFsdWU7XG5cdFx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuSURMRTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBTZXQgdmVsb2NpdHkgdG8gMCBzaW5jZSB3ZSdyZSBub3Qgc2Nyb2xsaW5nXG5cdFx0XHRcdFx0dmVsb2NpdHkgPSAwO1xuXHRcdFx0XHRcdC8vIFRoaXMgY2hlY2tzIGlmIHRoZSBzY3JvbGxUb1ZhbHVlIGNoYW5nZWQsIG9yIGlmIHRoZSBzdGF0ZSBjaGFuZ2VkIGZyb20gc3ByaW5nIHRvIHNjcm9sbC5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRwcmV2aW91c0xvZ2ljU3RhdGUgIT09IGxvZ2ljU3RhdGUgfHxcblx0XHRcdFx0XHRcdGRpZmYoc2Nyb2xsVG9WYWx1ZSkgIT09IDBcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIFN0b3AgZXZlcnl0aGluZywgcmVzZXR0aW5nIGl0XG5cdFx0XHRcdFx0XHRkZWNheVN0YXRlLnN0b3A7XG5cdFx0XHRcdFx0XHRzcHJpbmdTdGF0ZS5zdG9wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzcHJpbmdTdGF0ZS50aWNrO1xuXHRcdFx0XHRcdGlmIChzcHJpbmdTdGF0ZS5maW5pc2hlZCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0bG9naWNTdGF0ZSA9IExvZ2ljU3RhdGUuSURMRTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gU2Nyb2xsIGhhcyBlbmRlZFxuXHRcdGlmIChkaWZmKGxvZ2ljU3RhdGUpICE9PSAwICYmIGxvZ2ljU3RhdGUgPT09IExvZ2ljU3RhdGUuSURMRSkge1xuXHRcdFx0Y2FsbChbeFdpdGhDZW50ZXIsIGxvZ2ljU3RhdGVdLCBvblNjcm9sbEVuZCk7XG5cdFx0fVxuXHRcdC8vIFggaGFzIGNoYW5nZWRcblx0XHRjYWxsKFt4V2l0aENlbnRlcl0sIG9uWENoYW5nZSk7XG5cdFx0cHJldmlvdXNMb2dpY1N0YXRlID0gbG9naWNTdGF0ZTtcblx0XHR4V2l0aENlbnRlcjtcblx0fSk7XG5cblx0Y29uc3QgZ2VzdHVyZUhhbmRsZXIgPSBBbmltYXRlZC5ldmVudChbXG5cdFx0e1xuXHRcdFx0bmF0aXZlRXZlbnQ6IGdlc3R1cmVTdGF0ZS5kYXRhLFxuXHRcdH0sXG5cdF0pO1xuXG5cdGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoZXZlbnRFbWl0dGVyKTtcblxuXHRPYmplY3QuYXNzaWduKHJlc3VsdCwge1xuXHRcdHg6IGNhbGN1bGF0ZWRUcmFuc1gsXG5cdFx0Z2VzdHVyZUhhbmRsZXIsXG5cdFx0dXBkYXRlSXRlbVdpZHRoKHZhbHVlKSB7XG5cdFx0XHRpdGVtV2lkdGguc2V0VmFsdWUodmFsdWUpO1xuXHRcdH0sXG5cdFx0dXBkYXRlV3JhcHBlcldpZHRoKHZhbHVlKSB7XG5cdFx0XHR3cmFwcGVyV2lkdGguc2V0VmFsdWUodmFsdWUpO1xuXHRcdH0sXG5cdFx0dXBkYXRlQ2VudGVyU2Nyb2xsKHZhbHVlKSB7XG5cdFx0XHRjZW50ZXJTY3JvbGwuc2V0VmFsdWUodmFsdWUgPyAxIDogMCk7XG5cdFx0fSxcblx0XHR1cGRhdGVNYXhTY3JvbGwodmFsdWUpIHtcblx0XHRcdG1heFNjcm9sbFguc2V0VmFsdWUodmFsdWUpO1xuXHRcdH0sXG5cdFx0c2Nyb2xsVG8odmFsdWUsIHdpdGhBbmltYXRpb24gPSB0cnVlKSB7XG5cdFx0XHRzY3JvbGxUb1ZhbHVlLnNldFZhbHVlKHZhbHVlKTtcblx0XHRcdHNjcm9sbFRvV2l0aEFuaW1hdGlvbi5zZXRWYWx1ZSh3aXRoQW5pbWF0aW9uID8gMSA6IDApO1xuXHRcdFx0bG9naWNTdGF0ZS5zZXRWYWx1ZShMb2dpY1N0YXRlLlNDUk9MTF9UTyk7XG5cdFx0fSxcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cbiJdfQ==